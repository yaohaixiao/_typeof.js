{"version":3,"file":"types.min.js","sources":["enum/types.js","enum/objects.js","_type.js","isNumber.js","isInteger.js","isFloat.js","isInfinite.js","isString.js","isBlank.js","isBase64.js","isChinese.js","isEmail.js","isEmpty.js","isGuid.js","isIPAddress.js","isHex.js","enum/tags.js","isJSON.js","_isTime.js","_isDate.js","_getExactTypeOfString.js","isHTML.js","trim.js","isTime.js","isFunction.js","isPrototype.js","isUndefined.js","hasOwn.js","isObject.js","isVNode.js","isXML.js","isArray.js","isArrayLike.js","isObjectLike.js","isInt8Array.js","isNativeFunction.js","isPlainObject.js","types.js","is.js","_getExactTypeOfNumber.js","_getExactTypeOfObject.js","isArrayLikeObject.js","isArguments.js","isArrayBuffer.js","isUint8Array.js","isUint8ClampedArray.js","isInt16Array.js","isUint16Array.js","isInt32Array.js","isUint32Array.js","isFloat32Array.js","isFloat64Array.js","isBigInt64Array.js","isBigUint64Array.js","isBigInt.js","isBoolean.js","isConstructor.js","isDataView.js","isDate.js","isElement.js","isEmptyArray.js","isEmptyObject.js","isError.js","isEven.js","isFragment.js","isHash.js","isHTMLCollection.js","isLength.js","isMap.js","isNull.js","isNumeric.js","isOdd.js","isPhoneNumber.js","isPromise.js","isRegExp.js","isSet.js","isSymbol.js","isTextNode.js","isTypedArray.js","isURL.js","isValue.js","isWeakMap.js","isWeakSet.js"],"sourcesContent":["// 能够识别的数据类型名称枚举值\r\nconst TYPES = {\r\n  /* ===== Primitive data types ===== */\r\n  BIG_INT: 'bigint',\r\n  BOOLEAN: 'boolean',\r\n  NULL: 'null',\r\n  NUMBER: 'number',\r\n  UNDEFINED: 'undefined',\r\n  STRING: 'string',\r\n  SYMBOL: 'symbol',\r\n  /* ===== Keyed Collections ===== */\r\n  SET: 'set',\r\n  WEAK_SET: 'weakset',\r\n  MAP: 'map',\r\n  WEAK_MAP: 'weakmap',\r\n  /* ===== Array ===== */\r\n  ARRAY: 'array',\r\n  ARGUMENTS: 'arguments',\r\n  /* ===== Typed Arrays ===== */\r\n  DATA_VIEW: 'dataview',\r\n  ARRAY_BUFFER: 'arraybuffer',\r\n  INT8_ARRAY: 'int8array',\r\n  UNIT8_ARRAY: 'uint8array',\r\n  UNIT8_CLAMPED_ARRAY: 'uint8clampedarray',\r\n  INT16_ARRAY: 'int16array',\r\n  UNIT16_ARRAY: 'uint16array',\r\n  INT32_ARRAY: 'int32array',\r\n  UNIT32_ARRAY: 'uint32array',\r\n  FLOAT32_ARRAY: 'float32array',\r\n  FLOAT64_ARRAY: 'float64array',\r\n  BIG_INT64_ARRAY: 'bigint64array',\r\n  BIG_UINT64_ARRAY: 'biguint64array',\r\n  /* ===== Object ===== */\r\n  OBJECT: 'object',\r\n  COLLECTION: 'collection',\r\n  DATE: 'date',\r\n  ELEMENT: 'element',\r\n  ERROR: 'error',\r\n  FRAGMENT: 'fragment',\r\n  FUNCTION: 'function',\r\n  PROMISE: 'promise',\r\n  REGEXP: 'regexp',\r\n  TEXT: 'text'\r\n}\r\n\r\nexport default TYPES\r\n","import TYPES from './types'\r\n\r\n// Object.prototype.toString() 输出的类型名称枚举值\r\nconst OBJECTS = {\r\n  /* ===== Primitive data types ===== */\r\n  '[object Null]': TYPES.NULL,\r\n  /* ===== Keyed Collections ===== */\r\n  '[object Set]': TYPES.SET,\r\n  '[object WeakSet]': TYPES.WEAK_SET,\r\n  '[object Map]': TYPES.MAP,\r\n  '[object WeakMap]': TYPES.WEAK_MAP,\r\n  /* ===== Array ===== */\r\n  '[object Array]': TYPES.ARRAY,\r\n  '[object Arguments]': TYPES.ARGUMENTS,\r\n  /* ===== Typed Arrays ===== */\r\n  '[object DataView]': TYPES.DATA_VIEW,\r\n  '[object ArrayBuffer]': TYPES.ARRAY_BUFFER,\r\n  '[object Int8Array]': TYPES.INT8_ARRAY,\r\n  '[object Uint8Array]': TYPES.UNIT8_ARRAY,\r\n  '[object Uint8ClampedArray]': TYPES.UNIT8_CLAMPED_ARRAY,\r\n  '[object Int16Array]': TYPES.INT16_ARRAY,\r\n  '[object Uint16Array]': TYPES.UNIT16_ARRAY,\r\n  '[object Int32Array]': TYPES.INT32_ARRAY,\r\n  '[object Uint32Array]': TYPES.UNIT32_ARRAY,\r\n  '[object Float32Array]': TYPES.FLOAT32_ARRAY,\r\n  '[object Float64Array]': TYPES.FLOAT64_ARRAY,\r\n  '[object BigInt64Array]': TYPES.BIG_INT64_ARRAY,\r\n  '[object BigUint64Array]': TYPES.BIG_UINT64_ARRAY,\r\n  /* ===== Object ===== */\r\n  '[object Object]': TYPES.OBJECT,\r\n  '[object Boolean]': TYPES.OBJECT,\r\n  '[object String]': TYPES.OBJECT,\r\n  '[object Number]': TYPES.OBJECT,\r\n  '[object Date]': TYPES.DATE,\r\n  '[object Error]': TYPES.ERROR,\r\n  '[object DocumentFragment]': TYPES.FRAGMENT,\r\n  '[object Function]': TYPES.FUNCTION,\r\n  '[object NodeList]': TYPES.COLLECTION,\r\n  '[object Promise]': TYPES.PROMISE,\r\n  '[object RegExp]': TYPES.REGEXP,\r\n  '[object Text]': TYPES.TEXT\r\n}\r\n\r\nexport default OBJECTS\r\n","import TYPES from './enum/types'\r\nimport OBJECTS from './enum/objects'\r\n\r\n/**\r\n * 检测数据类型，返回检测数据类型的字符串\r\n * ========================================================================\r\n * @method _type\r\n * @param {*} val - 要检测的任意值\r\n * @returns {String}\r\n */\r\nconst _type = (val) => {\r\n  const type = Object.prototype.toString.apply(val)\r\n  const _typeof = typeof val\r\n  let name\r\n\r\n  // HTMLElement\r\n  if (val?.tagName && val.nodeType === 1) {\r\n    name = TYPES.ELEMENT\r\n  } else {\r\n    /* ===== 原始值类型（Primitive data types） ===== */\r\n    switch (_typeof) {\r\n      case 'bigint':\r\n        name = TYPES.BIG_INT\r\n        break\r\n      case 'string':\r\n        name = TYPES.STRING\r\n        break\r\n      case 'number':\r\n        name = TYPES.NUMBER\r\n        break\r\n      case 'boolean':\r\n        name = TYPES.BOOLEAN\r\n        break\r\n      case 'undefined':\r\n        name = TYPES.UNDEFINED\r\n        break\r\n      case 'symbol':\r\n        name = TYPES.SYMBOL\r\n        break\r\n      // 对象（引用）类型的数据\r\n      default:\r\n        name = OBJECTS[type]\r\n        break\r\n    }\r\n  }\r\n\r\n  return name || type\r\n}\r\n\r\nexport default _type\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Number 类型\r\n * ========================================================================\r\n * @method isNumber\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Number 类型，返回 true，否则返回 false\r\n */\r\nconst isNumber = (val) => {\r\n  return _type(val) === TYPES.NUMBER\r\n}\r\n\r\nexport default isNumber\r\n","import isNumber from './isNumber'\r\n\r\n/**\r\n * 检测测试数据是否为整数\r\n * ========================================================================\r\n * @method isInteger\r\n * @category Lang\r\n * @param {Number} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是整数，返回 true，否则返回 false\r\n */\r\nconst isInteger = (val) => {\r\n  return isNumber(val) && !isNaN(val) && Number(val) === val && val % 1 === 0\r\n}\r\n\r\nexport default isInteger\r\n","import isNumber from './isNumber'\r\nimport isInteger from './isInteger'\r\n\r\n/**\r\n * 检测测试数据是否为整数\r\n * ========================================================================\r\n * @method isFloat\r\n * @category Lang\r\n * @param {Number} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是整数，返回 true，否则返回 false\r\n */\r\nfunction isFloat(val) {\r\n  return (\r\n    isNumber(val) &&\r\n    !isNaN(val) &&\r\n    isFinite(val) &&\r\n    !isInteger(val) &&\r\n    Number(val) === val &&\r\n    val % 1 !== 0\r\n  )\r\n}\r\n\r\nexport default isFloat\r\n","import isNumber from './isNumber'\r\n\r\n/**\r\n * 检测测试数据的数据是正无穷或者负无穷\r\n * ========================================================================\r\n * @method isInfinite\r\n * @param {Number} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是正无穷或者负无穷，返回 true，否则返回 false\r\n */\r\nconst isInfinite = (val) => {\r\n  return isNumber(val) && (val === Infinity || val === -Infinity)\r\n}\r\n\r\nexport default isInfinite\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为字符串\r\n * ========================================================================\r\n * @method isString\r\n * @category Lang\r\n * @param {*} obj - 要检测的数据\r\n * @returns {Boolean} 'val' 是字符串，返回 true，否则返回 false\r\n */\r\nconst isString = (obj) => {\r\n  return _type(obj) === TYPES.STRING\r\n}\r\n\r\nexport default isString\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否只包空格\r\n * ========================================================================\r\n * @method isBlank\r\n * @param {String} val - 要检测的数据\r\n * @returns {Boolean} 'val' 只包含空格，返回 true，否则返回 false\r\n */\r\nfunction isBlank(val) {\r\n  if (!isString(val)) {\r\n    return false\r\n  }\r\n\r\n  return /^\\s*$/.test(val)\r\n}\r\n\r\nexport default isBlank\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为一个基于 base64 编码的字符串。\r\n * ========================================================================\r\n * @method isBase64\r\n * @param {String} val - 要检测的数据\r\n * @return {Boolean} 'val' 是 base64 编码的字符串，返回 true，否则返回 false\r\n */\r\nconst isBase64 = (val) => {\r\n  const REGEXP_BASE64 =\r\n    /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}={2})$/gm\r\n  return isString(val) && (!val.length || REGEXP_BASE64.test(val))\r\n}\r\n\r\nexport default isBase64\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测字符串是否为中文字符\r\n * ========================================================================\r\n * Wiki 介绍中文字符包含以下内容：\r\n *\r\n * 1. 中文汉字\r\n * 2. 象形文字扩展 A-H\r\n * 3. 兼容象形文字符\r\n * 4. 兼容表意文字增补字符\r\n * 5. 中文标点符号\r\n * 6. 兼容标点符号\r\n *\r\n * 其中：\r\n *\r\n * 兼容象形文字符：[0xf900, 0xfaff],（https://en.wikipedia.org/wiki/CJK_Compatibility_Ideographs）和\r\n * 兼容表意文字增补字符：[0x2f800, 0x2fa1f]（https://en.wikipedia.org/wiki/CJK_Compatibility_Ideographs_Supplement）\r\n *\r\n * 只是看上去像汉字，因此在 isChinese() 方法中也没有纳入到汉字字符\r\n * ========================================================================\r\n * @method isChinese\r\n * @since 1.2.0\r\n * @param {String} str - （必须）检测字符串\r\n * @param {Boolean} [includePunctuation] - （可选）是否包含标点符号：默认值：true\r\n * @returns {boolean} - ‘val’ 是中文字符，返回 true，否则返回 false;\r\n */\r\nconst isChinese = (str, includePunctuation = true) => {\r\n  // 转换成正则表达式\r\n  const toRegExp = (range) => {\r\n    const pattern = range\r\n      .map((range) => {\r\n        const rangeStart = range[0]\r\n        const rangeEnd = range[1]\r\n        const hexStart = rangeStart.toString(16)\r\n        const hexEnd = rangeEnd.toString(16)\r\n\r\n        if (rangeStart === rangeEnd) {\r\n          return `\\\\u{${hexStart}}`\r\n        }\r\n        return `[\\\\u{${hexStart}}-\\\\u{${hexEnd}}]`\r\n      })\r\n      .join('|')\r\n\r\n    return new RegExp(`^(?:${pattern})+$`, 'u')\r\n  }\r\n  // 文字\r\n  // https://en.wikipedia.org/wiki/CJK_Unified_Ideographs\r\n  const chineseIdeographs = [\r\n    // 中文汉字\r\n    [0x4e00, 0x9fff],\r\n\r\n    // 象形文字扩展 A - H\r\n    [0x3400, 0x4dbf],\r\n    [0x20000, 0x2a6df],\r\n    [0x2a700, 0x2b73f],\r\n    [0x2b740, 0x2b81f],\r\n    [0x2b820, 0x2ceaf],\r\n    [0x2ceb0, 0x2ebef],\r\n    [0x30000, 0x3134f],\r\n    [0x31350, 0x323af]\r\n  ]\r\n  // 标点符号\r\n  const chinesePunctuations = [\r\n    // ，\r\n    [0xff0c, 0xff0c],\r\n    // 。\r\n    [0x3002, 0x3002],\r\n    // ·\r\n    [0x00b7, 0x00b7],\r\n    // ×\r\n    [0x00d7, 0x00d7],\r\n    // —\r\n    [0x2014, 0x2014],\r\n    // ‘\r\n    [0x2018, 0x2018],\r\n    // ’\r\n    [0x2019, 0x2019],\r\n    // “\r\n    [0x201c, 0x201c],\r\n    // ”\r\n    [0x201d, 0x201d],\r\n    // …\r\n    [0x2026, 0x2026],\r\n    // 、\r\n    [0x3001, 0x3001],\r\n    // 《\r\n    [0x300a, 0x300a],\r\n    // 》\r\n    [0x300b, 0x300b],\r\n    // 『\r\n    [0x300e, 0x300e],\r\n    // 』\r\n    [0x300f, 0x300f],\r\n    // 【\r\n    [0x3010, 0x3010],\r\n    // 】\r\n    [0x3011, 0x3011],\r\n    // ！\r\n    [0xff01, 0xff01],\r\n    // （\r\n    [0xff08, 0xff08],\r\n    // ）\r\n    [0xff09, 0xff09],\r\n    // ：\r\n    [0xff1a, 0xff1a],\r\n    // ；\r\n    [0xff1b, 0xff1b],\r\n    // ？\r\n    [0xff1f, 0xff1f],\r\n    // ～\r\n    [0xff5e, 0xff5e],\r\n    // 兼容性标点符号\r\n    // https://en.wikipedia.org/wiki/CJK_Compatibility_Forms\r\n    [0xfe30, 0xfe4f]\r\n  ]\r\n  const asciiChars = /\\w+/\r\n\r\n  if (!isString(str)) {\r\n    return false\r\n  }\r\n\r\n  if (asciiChars.test(str)) {\r\n    return false\r\n  }\r\n\r\n  const pattern = includePunctuation\r\n    ? toRegExp(chineseIdeographs.concat(chinesePunctuations))\r\n    : toRegExp(chineseIdeographs)\r\n\r\n  return pattern.test(str)\r\n}\r\n\r\nexport default isChinese\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测是否为正确的 Email 邮箱地址格式\r\n * ========================================================================\r\n * @method isEmail\r\n * @category Lang\r\n * @param {String} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Email 邮箱地址格式，返回 true，否则返回 false\r\n */\r\nconst isEmail = (val) => {\r\n  const pattern =\r\n    /^([a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?)$/\r\n  return isString(val) && pattern.test(val)\r\n}\r\n\r\nexport default isEmail\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为空字符串\r\n * ========================================================================\r\n * @method isEmpty\r\n * @category Lang\r\n * @param {String} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是空字符串，返回 true，否则返回 false\r\n */\r\nconst isEmpty = (val) => {\r\n  return isString(val) && val === ''\r\n}\r\n\r\nexport default isEmpty\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为 Guid 格式字符串\r\n * ========================================================================\r\n * @method isGuid\r\n * @since 1.4.0\r\n * @category Lang\r\n * @param {String} str - 待检测数据（字符串）\r\n * @returns {Boolean} 'val' 是 Guid 格式字符串，返回 true，否则返回 false\r\n */\r\nconst isGuid = (str) => {\r\n  const patternWithHyphens =\r\n    /^{?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}}?$/gi\r\n  const patternWithoutHyphens =\r\n    /^{?[0-9a-fA-F]{8}[0-9a-fA-F]{4}[0-9a-fA-F]{4}[0-9a-fA-F]{4}[0-9a-fA-F]{12}}?$/gi\r\n\r\n  let guid\r\n\r\n  if (!isString(str)) {\r\n    return false\r\n  }\r\n\r\n  guid = str.replace(/^[{}]$/i, '')\r\n\r\n  return patternWithHyphens.test(guid) || patternWithoutHyphens.test(guid)\r\n}\r\n\r\nexport default isGuid\r\n","import isString from './isString'\r\n\r\n/**\r\n * 验证是否为（v4 or v6） IP 地址\r\n * ========================================================================\r\n * @method isIPAddress\r\n * @category Lang\r\n * @param {String} str - 待检测的数据（字符串）\r\n * @returns {Boolean} 'val' 是 IP 地址，返回 true，否则返回 false\r\n */\r\nconst isIPAddress = (str) => {\r\n  const ipV6 =\r\n    /(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]+|::(ffff(:0{1,4})?:)?((25[0-5]|(2[0-4]|1?\\d)?\\d)\\.){3}(25[0-5]|(2[0-4]|1?\\d)?\\d)|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1?\\d)?\\d)\\.){3}(25[0-5]|(2[0-4]|1?\\d)?\\d))/\r\n  const ipV4 =\r\n    /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/\r\n  return isString(str) && (ipV4.test(str) || ipV6.test(str))\r\n}\r\n\r\nexport default isIPAddress\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为 16 进制编码的字符串\r\n * ========================================================================\r\n * @method isHex\r\n * @param {String} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 16 进制编码的字符串，返回 true，否则返回 false\r\n */\r\nconst isHex = (val) => {\r\n  const REGEXP_HEX = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n  return isString(val) && REGEXP_HEX.test(val)\r\n}\r\n\r\nexport default isHex\r\n","// HTML 合法的标签\r\nconst TAGS = [\r\n  'a',\r\n  'abbr',\r\n  'address',\r\n  'area',\r\n  'article',\r\n  'aside',\r\n  'audio',\r\n  'b',\r\n  'base',\r\n  'bdi',\r\n  'bdo',\r\n  'blockquote',\r\n  'body',\r\n  'br',\r\n  'button',\r\n  'canvas',\r\n  'caption',\r\n  'cite',\r\n  'code',\r\n  'col',\r\n  'colgroup',\r\n  'data',\r\n  'datalist',\r\n  'dd',\r\n  'del',\r\n  'details',\r\n  'dfn',\r\n  'dialog',\r\n  'div',\r\n  'dl',\r\n  'dt',\r\n  'em',\r\n  'embed',\r\n  'fieldset',\r\n  'figcaption',\r\n  'figure',\r\n  'footer',\r\n  'form',\r\n  'h1',\r\n  'h2',\r\n  'h3',\r\n  'h4',\r\n  'h5',\r\n  'h6',\r\n  'head',\r\n  'header',\r\n  'hgroup',\r\n  'hr',\r\n  'html',\r\n  'i',\r\n  'iframe',\r\n  'img',\r\n  'input',\r\n  'ins',\r\n  'kbd',\r\n  'label',\r\n  'legend',\r\n  'li',\r\n  'link',\r\n  'main',\r\n  'map',\r\n  'mark',\r\n  'math',\r\n  'menu',\r\n  'menuitem',\r\n  'meta',\r\n  'meter',\r\n  'nav',\r\n  'noscript',\r\n  'object',\r\n  'ol',\r\n  'optgroup',\r\n  'option',\r\n  'output',\r\n  'p',\r\n  'param',\r\n  'picture',\r\n  'pre',\r\n  'progress',\r\n  'q',\r\n  'rb',\r\n  'rp',\r\n  'rt',\r\n  'rtc',\r\n  'ruby',\r\n  's',\r\n  'samp',\r\n  'script',\r\n  'search',\r\n  'section',\r\n  'select',\r\n  'slot',\r\n  'small',\r\n  'source',\r\n  'span',\r\n  'strong',\r\n  'style',\r\n  'sub',\r\n  'summary',\r\n  'sup',\r\n  'svg',\r\n  'table',\r\n  'tbody',\r\n  'td',\r\n  'template',\r\n  'textarea',\r\n  'tfoot',\r\n  'th',\r\n  'thead',\r\n  'time',\r\n  'title',\r\n  'tr',\r\n  'track',\r\n  'u',\r\n  'ul',\r\n  'var',\r\n  'video',\r\n  'wbr'\r\n]\r\n\r\nexport default TAGS\r\n","import isString from './isString'\r\nimport isBlank from './isBlank'\r\n\r\n/**\r\n * 检测测试数据是否为 JSON 格式字符串数据\r\n * ========================================================================\r\n * @method isJSON\r\n * @param {String} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 JSON 格式字符串，返回 true，否则返回 false\r\n */\r\nconst isJSON = (val) => {\r\n  if (!isString(val) || isBlank(val) || !val) {\r\n    return false\r\n  }\r\n\r\n  val = val.replace(/\\\\(?:([\"\\\\/bfnrt])|(u[0-9a-fA-F]{4}))/g, '@')\r\n  val = val.replace(\r\n    /\"[\\w\\s]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?/g,\r\n    ']'\r\n  )\r\n  val = val.replace(/(?:^|:|,)(?:\\s*\\[)+/g, '')\r\n\r\n  return /^[\\],:{}\\s]*$/.test(val)\r\n}\r\n\r\nexport default isJSON\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为有效的时间（字符串）\r\n * ========================================================================\r\n * @method _isTime\r\n * @private\r\n * @param {String} str - 待检测数据（字符串）\r\n * @returns {Boolean}\r\n */\r\nconst _isTime = (str) => {\r\n  const pattern12Hours = /^(0?[1-9]|1[0-2]):[0-5]\\d(\\s(am|pm|AM|PM))?$/\r\n  const pattern24Hours = /^(0?[1-9]|2[0-3]):([0-5]\\d){1,2}$/\r\n\r\n  return isString(str) && (pattern12Hours.test(str) || pattern24Hours.test(str))\r\n}\r\n\r\nexport default _isTime\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为有效的日期（字符串）\r\n * ========================================================================\r\n * @method _isDate\r\n * @private\r\n * @param {String} str - 待检测数据（字符串）\r\n * @returns {Boolean}\r\n */\r\nconst _isDate = (str) => {\r\n  return isString(str) && !isNaN(Date.parse(str))\r\n}\r\n\r\nexport default _isDate\r\n","import isBlank from './isBlank'\r\nimport isBase64 from './isBase64'\r\nimport isChinese from './isChinese'\r\nimport isEmail from './isEmail'\r\nimport isEmpty from './isEmpty'\r\nimport isGuid from './isGuid'\r\nimport isIPAddress from './isIPAddress'\r\nimport isHex from './isHex'\r\nimport isHTML from './isHTML'\r\nimport isJSON from './isJSON'\r\nimport isTime from './isTime'\r\n\r\n/**\r\n * （私有方法）获取确切的字符串类型\r\n * ========================================================================\r\n * @method _getExactTypeOfString\r\n * @private\r\n * @param {String} val - 要检测的字符串\r\n * @returns {String} 返回字符串类型：blank、chinese、email、empty... 等等\r\n */\r\nconst _getExactTypeOfString = (val) => {\r\n  let name = 'string'\r\n\r\n  if (isEmpty(val)) {\r\n    name = 'empty'\r\n  } else if (isBlank(val)) {\r\n    name = 'blank'\r\n  } else if (isGuid(val)) {\r\n    name = 'guid'\r\n  } else if (isBase64(val)) {\r\n    name = 'base64'\r\n  } else if (isChinese(val)) {\r\n    name = 'chinese'\r\n  } else if (isEmail(val)) {\r\n    name = 'email'\r\n  } else if (isIPAddress(val)) {\r\n    name = 'IP address'\r\n  } else if (isHex(val)) {\r\n    name = 'hex'\r\n  } else if (isHTML(val)) {\r\n    name = 'html'\r\n  } else if (isJSON(val)) {\r\n    name = 'json'\r\n  } else if (isTime(val)) {\r\n    name = 'time'\r\n  }\r\n\r\n  return name\r\n}\r\n\r\nexport default _getExactTypeOfString\r\n","import isString from './isString'\r\nimport trim from './trim'\r\nimport TAGS from './enum/tags'\r\n\r\n/**\r\n * 检测测试数据是否为合法的 HTML 代码\r\n * ========================================================================\r\n * @method isHTML\r\n * @since 0.5.0\r\n * @category Lang\r\n * @see https://github.com/sindresorhus/html-tags\r\n * @see https://github.com/sindresorhus/is-html\r\n * @param {String} str - 要检测的数据\r\n * @returns {Boolean} 'val' 为合法的 HTML 代码，返回 true，否则返回 false\r\n */\r\nconst isHTML = (str) => {\r\n  let html\r\n  let basic\r\n  let full\r\n\r\n  if (!isString(str)) {\r\n    return false\r\n  }\r\n\r\n  // 为了提高性能，我们将其限制在合理的长度内。\r\n  html = trim(str).slice(0, 1000)\r\n  basic = /\\s*<!doctype html>|<html\\b[^>]*>|<body\\b[^>]*>|<x-[^>]+>/i\r\n  full = new RegExp(TAGS.map((tag) => `<${tag}\\\\b[^>]*>`).join('|'), 'i')\r\n\r\n  return basic.test(html) || full.test(html)\r\n}\r\n\r\nexport default isHTML\r\n","const trim = (str) => {\n  /* istanbul ignore else */\n  if (str.trim) {\n    return str.trim()\n  }\n\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nexport default trim\n","import _isTime from './_isTime'\r\nimport _isDate from './_isDate'\r\n\r\n/**\r\n * 检测测试数据是否为有效的时间（字符串）\r\n * ========================================================================\r\n * @method isTime\r\n * @since 1.4.0\r\n * @param {String} str - （必须）待测试的字符串\r\n * @param {String} [type] - 测试的时间类型：\r\n *                          time - 时间；\r\n *                          date - 日期；\r\n *                          不传 - 时间或者日期皆可\r\n * @returns {Boolean} 'val' 是有效的时间（字符串），返回 true，否则返回 false\r\n */\r\nconst isTime = (str, type) => {\r\n  switch (type) {\r\n    case 'time':\r\n      return _isTime(str)\r\n    case 'date':\r\n      return _isDate(str)\r\n    default:\r\n      return _isTime(str) || _isDate(str)\r\n  }\r\n}\r\n\r\nexport default isTime\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Function 类型\r\n * ========================================================================\r\n * @method isFunction\r\n * @category Lang\r\n * @param {*} val - （必须）待检测的数据\r\n * @returns {Boolean} 'val' 是 Function 类型，返回 true，否则返回 false\r\n */\r\nconst isFunction = (val) => {\r\n  const type = _type(val)\r\n  return type === TYPES.FUNCTION\r\n}\r\n\r\nexport default isFunction\r\n","import isFunction from './isFunction'\r\n\r\n/**\r\n * 判断是否为 prototype 对象\r\n * ========================================================================\r\n * @method isPrototype\r\n * @param {Function|Object} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 prototype 对象，返回 true，否则返回 false\r\n */\r\nconst isPrototype = (val) => {\r\n  const OP = Object.prototype\r\n  const Ctor = val ? val.constructor : null\r\n  const proto = (isFunction(Ctor) && Ctor.prototype) || OP\r\n\r\n  return val === proto\r\n}\r\n\r\nexport default isPrototype\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否 undefined（未定义）\r\n * ========================================================================\r\n * @method isUndefined\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 undefined（未定义），返回 true，否则返回 false\r\n */\r\nconst isUndefined = (val) => {\r\n  return _type(val) === TYPES.UNDEFINED\r\n}\r\n\r\nexport default isUndefined\r\n","import isUndefined from './isUndefined'\n\n/**\n * 检测对象自身属性中是否具有指定的属性。\n * ========================================================================\n * @method hasOwn\n * @param {Object} obj - （必须）检测的目标对象\n * @param {String} prop - （必须）属性名\n * @returns {Boolean}\n */\nconst hasOwn = (obj, prop) => {\n  const hasOwnProperty = Object.prototype.hasOwnProperty\n\n  if (hasOwnProperty) {\n    // 不建议直接实用对象从原型链继承的 hasOwnProperty() 方法\n    // 所以采用直接调用 Object.prototype.hasOwnProperty() 方法\n    return hasOwnProperty.call(obj, prop)\n  }\n\n  return (\n    // 从对象构造函数的原型链继承的同名属性不算 obj 自身的属性\n    !isUndefined(obj[prop]) && obj.constructor.prototype[prop] !== obj[prop]\n  )\n}\n\nexport default hasOwn\n","import isFunction from './isFunction'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为对象\r\n * ========================================================================\r\n * @method isObject\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 为对象，返回 true，否则返回 false\r\n */\r\nconst isObject = (val) => {\r\n  const type = typeof val\r\n\r\n  return !!(val && (type === TYPES.OBJECT || isFunction(val)))\r\n}\r\n\r\nexport default isObject\r\n","import hasOwn from './hasOwn'\r\nimport isObject from './isObject'\r\n\r\n/**\r\n * 判断是否未 VNode 对象\r\n * =============================================================\r\n * @method isVNode\r\n * @param {Object} node - 要检测的数据\r\n * @returns {Boolean} 'val' 是 VNode 类型，返回 true，否则返回 false\r\n */\r\nconst isVNode = (node) => {\r\n  return node !== null && isObject(node) && hasOwn(node, 'componentOptions')\r\n}\r\n\r\nexport default isVNode\r\n","/**\r\n * 检测是否为 XML 文档\r\n * ========================================================================\r\n * @method isXML\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 XML 文档，返回 true，否则返回 false\r\n */\r\nconst isXML = (val) => {\r\n  const documentElement = val && (val.ownerDocument || val).documentElement\r\n  return documentElement ? documentElement.nodeName !== 'HTML' : false\r\n}\r\n\r\nexport default isXML\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Array 类型\r\n * ========================================================================\r\n * @method isArray\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} - 'val' 是 Array 类型，返回 true，否则返回 false\r\n */\r\nconst isArray = (val) => {\r\n  return Array.isArray ? Array.isArray(val) : _type(val) === TYPES.ARRAY\r\n}\r\n\r\nexport default isArray\r\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为类似数组（array、arguments 对象或者\n * HTMLNodeList 对象）类型。\n * ========================================================================\n * @method isArrayLike\n * @param {*} val - 要检测是的数据\n * @returns {Boolean} 'val' 是 array、arguments 或者 HTMLNodeList 类型返回 true，否则返回 false\n */\nconst isArrayLike = (val) => {\n  const type = _type(val)\n\n  return (\n    type === TYPES.ARRAY ||\n    type === TYPES.ARGUMENTS ||\n    type === TYPES.COLLECTION\n  )\n}\n\nexport default isArrayLike\n","import isObject from './isObject'\r\n\r\n/**\r\n * 检测测试数据是否为类似 Object 类型\r\n * ========================================================================\r\n * @method isObjectLike\r\n * @param {Object} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是类似 Object 类型，返回 true，否则返回 false\r\n */\r\nconst isObjectLike = (val) => {\r\n  return isObject(val) && val !== null\r\n}\r\n\r\nexport default isObjectLike\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Int8Array 的数组\r\n * ========================================================================\r\n * methods isInt8Array\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Int32Array 类型，返回 true，否则返回 false\r\n */\r\nconst isInt8Array = (val) => {\r\n  return _type(val) === TYPES.INT8_ARRAY\r\n}\r\n\r\nexport default isInt8Array\r\n","import isFunction from './isFunction'\r\n\r\n/**\r\n * 检测测试数据是否为 JavaScript 内置函数\r\n * ========================================================================\r\n * @method isNativeFunction\r\n * @param {Function|Object} fn - 要测试的函数\r\n * @returns {Boolean} - fn 是内置函数，返回 true，否则返回 false;\r\n */\r\nconst isNativeFunction = (fn) => {\r\n  return isFunction(fn) && /\\{\\s*\\[native code\\]\\s*\\}/.test('' + fn)\r\n}\r\n\r\nexport default isNativeFunction\r\n","import isObjectLike from './isObjectLike'\n\n/**\n * 检测测试数据是否为普通对象\n * ========================================================================\n * @method isPlainObject\n * @param {Object} val - 要检测的数据\n * @returns {Boolean} 'val' 是普通对象，返回 true，否则返回 false\n */\nconst isPlainObject = (val) => {\n  const getPrototypeOf = Object.getPrototypeOf\n  let proto\n\n  // Detect obvious negatives\n  if (!isObjectLike(val)) {\n    return false\n  }\n\n  proto = val.prototype\n\n  // JavaScript 对象分为两种：普通对象和函数对象\n  // 普通对象：原型是 __proto__，没有 prototype 原型（属性）\n  // 函数对象：原型是 prototype ，prototype 只存在于函数对象上\n  if (!proto) {\n    return true\n  }\n\n  proto = val\n\n  while (getPrototypeOf(proto) !== null) {\n    proto = getPrototypeOf(proto)\n  }\n\n  return getPrototypeOf(val) === proto\n}\n\nexport default isPlainObject\n","import is from './is'\r\nimport isArray from './isArray'\r\nimport isArrayLike from './isArrayLike'\r\nimport isArrayLikeObject from './isArrayLikeObject'\r\nimport isArguments from './isArguments'\r\nimport isArrayBuffer from './isArrayBuffer'\r\nimport isInt8Array from './isInt8Array'\r\nimport isUint8Array from './isUint8Array'\r\nimport isUint8ClampedArray from './isUint8ClampedArray'\r\nimport isInt16Array from './isInt16Array'\r\nimport isUint16Array from './isUint16Array'\r\nimport isInt32Array from './isInt32Array'\r\nimport isUint32Array from './isUint32Array'\r\nimport isFloat32Array from './isFloat32Array'\r\nimport isFloat64Array from './isFloat64Array'\r\nimport isBigInt64Array from './isBigInt64Array'\r\nimport isBigUint64Array from './isBigUint64Array'\r\nimport isBigInt from './isBigInt'\r\nimport isBase64 from './isBase64'\r\nimport isBlank from './isBlank'\r\nimport isBoolean from './isBoolean'\r\nimport isConstructor from './isConstructor'\r\nimport isDataView from './isDataView'\r\nimport isDate from './isDate'\r\nimport isElement from './isElement'\r\nimport isEmail from './isEmail'\r\nimport isEmpty from './isEmpty'\r\nimport isEmptyArray from './isEmptyArray'\r\nimport isEmptyObject from './isEmptyObject'\r\nimport isError from './isError'\r\nimport isEven from './isEven'\r\nimport isFloat from './isFloat'\r\nimport isFragment from './isFragment'\r\nimport isFunction from './isFunction'\r\nimport isGuid from './isGuid'\r\nimport isHash from './isHash'\r\nimport isHex from './isHex'\r\nimport isHTMLCollection from './isHTMLCollection'\r\nimport isInfinite from './isInfinite'\r\nimport isInteger from './isInteger'\r\nimport isIPAddress from './isIPAddress'\r\nimport isJSON from './isJSON'\r\nimport isLength from './isLength'\r\nimport isMap from './isMap'\r\nimport isNativeFunction from './isNativeFunction'\r\nimport isNull from './isNull'\r\nimport isNumber from './isNumber'\r\nimport isNumeric from './isNumeric'\r\nimport isObject from './isObject'\r\nimport isObjectLike from './isObjectLike'\r\nimport isOdd from './isOdd'\r\nimport isChinese from './isChinese'\r\nimport isPhoneNumber from './isPhoneNumber'\r\nimport isPlainObject from './isPlainObject'\r\nimport isPromise from './isPromise'\r\nimport isPrototype from './isPrototype'\r\nimport isRegExp from './isRegExp'\r\nimport isSet from './isSet'\r\nimport isString from './isString'\r\nimport isSymbol from './isSymbol'\r\nimport isTextNode from './isTextNode'\r\nimport isTypedArray from './isTypedArray'\r\nimport isUndefined from './isUndefined'\r\nimport isURL from './isURL'\r\nimport isValue from './isValue'\r\nimport isVNode from './isVNode'\r\nimport isWeakMap from './isWeakMap'\r\nimport isWeakSet from './isWeakSet'\r\nimport isXML from './isXML'\r\n\r\nconst Types = {\r\n  is,\r\n  isArray,\r\n  isArrayLike,\r\n  isArrayLikeObject,\r\n  isArguments,\r\n  isArrayBuffer,\r\n  isInt8Array,\r\n  isUint8Array,\r\n  isUint8ClampedArray,\r\n  isInt16Array,\r\n  isUint16Array,\r\n  isInt32Array,\r\n  isUint32Array,\r\n  isFloat32Array,\r\n  isFloat64Array,\r\n  isBigInt64Array,\r\n  isBigUint64Array,\r\n  isBigInt,\r\n  isBase64,\r\n  isBlank,\r\n  isBoolean,\r\n  isConstructor,\r\n  isDataView,\r\n  isDate,\r\n  isElement,\r\n  isEmail,\r\n  isEmpty,\r\n  isEmptyArray,\r\n  isEmptyObject,\r\n  isError,\r\n  isEven,\r\n  isFloat,\r\n  isFragment,\r\n  isFunction,\r\n  isGuid,\r\n  isHash,\r\n  isHex,\r\n  isHTMLCollection,\r\n  isInfinite,\r\n  isInteger,\r\n  isIPAddress,\r\n  isJSON,\r\n  isLength,\r\n  isMap,\r\n  isNativeFunction,\r\n  isNull,\r\n  isNumber,\r\n  isNumeric,\r\n  isObject,\r\n  isObjectLike,\r\n  isOdd,\r\n  isChinese,\r\n  isPhoneNumber,\r\n  isPlainObject,\r\n  isPromise,\r\n  isPrototype,\r\n  isRegExp,\r\n  isSet,\r\n  isString,\r\n  isSymbol,\r\n  isTextNode,\r\n  isTypedArray,\r\n  isUndefined,\r\n  isURL,\r\n  isValue,\r\n  isVNode,\r\n  isWeakMap,\r\n  isWeakSet,\r\n  isXML\r\n}\r\n\r\nexport default Types\r\n","import _type from './_type'\r\nimport _getExactTypeOfNumber from './_getExactTypeOfNumber'\r\nimport _getExactTypeOfString from './_getExactTypeOfString'\r\nimport _getExactTypeOfObject from './_getExactTypeOfObject'\r\n\r\n/**\r\n * 检测数据类型，返回检测数据类型的字符串\r\n * ========================================================================\r\n * @method is\r\n * @category Lang\r\n * @see _type\r\n * @param {*} val - 要检测的任意值\r\n * @returns {String} 返回确切的数据类型名称\r\n */\r\nconst is = (val) => {\r\n  const type = _type(val)\r\n  let name\r\n\r\n  switch (type) {\r\n    case 'number':\r\n      name = _getExactTypeOfNumber(val)\r\n      break\r\n    case 'string':\r\n      name = _getExactTypeOfString(val)\r\n      break\r\n    case 'object':\r\n      name = _getExactTypeOfObject(val)\r\n      break\r\n    default:\r\n      name = type\r\n      break\r\n  }\r\n\r\n  return name\r\n}\r\n\r\nexport default is\r\n","import isInteger from './isInteger'\r\nimport isFloat from './isFloat'\r\nimport isInfinite from './isInfinite'\r\n\r\n/**\r\n * （私有方法）获取确切的数值类型\r\n * ========================================================================\r\n * @method _getExactTypeOfNumber\r\n * @private\r\n * @param {Number} val - 要检测的数值\r\n * @returns {String} - 返回数值类型：integer、float、infinite\r\n */\r\nconst _getExactTypeOfNumber = (val) => {\r\n  let name = 'number'\r\n\r\n  if (isInteger(val)) {\r\n    name = 'integer'\r\n  } else if (isFloat(val)) {\r\n    name = 'float'\r\n  } else if (isInfinite(val)) {\r\n    name = 'infinite'\r\n  }\r\n\r\n  return name\r\n}\r\n\r\nexport default _getExactTypeOfNumber\r\n","import isPrototype from './isPrototype'\r\nimport isVNode from './isVNode'\r\nimport isXML from './isXML'\r\n\r\n/**\r\n * （私有方法）获取确切的对象类型\r\n * ========================================================================\r\n * @method _getExactTypeOfString\r\n * @private\r\n * @param {String} val - 要检测的字符串\r\n * @returns {String} 返回对象类型：prototype、vnode、xml\r\n */\r\nconst _getExactTypeOfObject = (val) => {\r\n  let name = 'object'\r\n\r\n  if (isXML(val)) {\r\n    name = 'xml'\r\n  } else if (isVNode(val)) {\r\n    name = 'vnode'\r\n  } else if (isPrototype(val)) {\r\n    name = 'prototype'\r\n  }\r\n\r\n  return name\r\n}\r\n\r\nexport default _getExactTypeOfObject\r\n","import isArrayLike from './isArrayLike'\r\nimport isObjectLike from './isObjectLike'\r\n\r\n/**\r\n * 检测测试数据是否为 ArrayLike 的对象数据\r\n * ========================================================================\r\n * @method isArrayLikeObject\r\n * @param {Object|Array} val - 要检测的数据\r\n * @returns {Boolean} ‘val’ 是类似 Array 类型对象，返回 true，否则返回 false;\r\n */\r\nconst isArrayLikeObject = (val) => {\r\n  return isObjectLike(val) && isArrayLike(val)\r\n}\r\n\r\nexport default isArrayLikeObject\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 arguments 对象\r\n * ========================================================================\r\n * @method isArguments\r\n * @param {*} val - 要检测的数据\r\n * @return {Boolean} ‘val’ 是 Arguments 对象，返回 true，否则返回 false;\r\n */\r\nfunction isArguments(val) {\r\n  return _type(val) === TYPES.ARGUMENTS\r\n}\r\n\r\nexport default isArguments\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 ArrayBuffer 类型\r\n * ========================================================================\r\n * @method isArrayBuffer\r\n * @category Lang\r\n * @param {*} val\r\n * @return {Boolean} ‘val’ 是 isArrayBuffer 类型，返回 true，否则返回 false\r\n */\r\nfunction isArrayBuffer(val) {\r\n  return _type(val) === TYPES.ARRAY_BUFFER\r\n}\r\n\r\nexport default isArrayBuffer\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Uint8Array 的数组\r\n * ========================================================================\r\n * methods isUint8Array\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Uint8Array 类型，返回 true，否则返回 false\r\n */\r\nconst isUint8Array = (val) => {\r\n  return _type(val) === TYPES.UNIT8_ARRAY\r\n}\r\n\r\nexport default isUint8Array\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Uint8ClampedArray 的数组\r\n * ========================================================================\r\n * methods isUint8ClampedArray\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Uint8ClampedArray 类型，返回 true，否则返回 false\r\n */\r\nconst isUint8ClampedArray = (val) => {\r\n  return _type(val) === TYPES.UNIT8_CLAMPED_ARRAY\r\n}\r\n\r\nexport default isUint8ClampedArray\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Int16Array 的数组\r\n * ========================================================================\r\n * methods isInt16Array\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Int32Array 类型，返回 true，否则返回 false\r\n */\r\nconst isInt16Array = (val) => {\r\n  return _type(val) === TYPES.INT16_ARRAY\r\n}\r\n\r\nexport default isInt16Array\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Uint16Array 的数组\r\n * ========================================================================\r\n * methods isUint16Array\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Uint16Array 类型，返回 true，否则返回 false\r\n */\r\nconst isUint16Array = (val) => {\r\n  return _type(val) === TYPES.UNIT16_ARRAY\r\n}\r\n\r\nexport default isUint16Array\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Int32Array 的数组\r\n * ========================================================================\r\n * methods isInt32Array\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Int32Array 类型，返回 true，否则返回 false\r\n */\r\nconst isInt32Array = (val) => {\r\n  return _type(val) === TYPES.INT32_ARRAY\r\n}\r\n\r\nexport default isInt32Array\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Uint32Array 的数组\r\n * ========================================================================\r\n * methods isUint32Array\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Uint32Array 类型，返回 true，否则返回 false\r\n */\r\nconst isUint32Array = (val) => {\r\n  return _type(val) === TYPES.UNIT32_ARRAY\r\n}\r\n\r\nexport default isUint32Array\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Float32Array 的数组\r\n * ========================================================================\r\n * methods isFloat32Array\r\n * @param {*} val - （必须）待检测的数据\r\n * @returns {Boolean} 'val' 是 Float64Array 类型，返回 true，否则返回 false\r\n */\r\nconst isFloat32Array = (val) => {\r\n  return _type(val) === TYPES.FLOAT32_ARRAY\r\n}\r\n\r\nexport default isFloat32Array\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Float64Array 的数组\r\n * ========================================================================\r\n * methods isFloat64Array\r\n * @param {*} val - （必须）待检测的数据\r\n * @returns {Boolean} 'val' 是 Float64Array 类型，返回 true，否则返回 false\r\n */\r\nconst isFloat64Array = (val) => {\r\n  return _type(val) === TYPES.FLOAT64_ARRAY\r\n}\r\n\r\nexport default isFloat64Array\r\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 BigInt64Array 类型。\n * ========================================================================\n * @method isBigInt64Array\n * @since 0.6.0\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 BigInt64Array 类型，返回 true，否则返回 false\n */\nconst isBigInt64Array = (val) => {\n  return _type(val) === TYPES.BIG_INT64_ARRAY\n}\n\nexport default isBigInt64Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 BigUint64Array 类型。\n * ========================================================================\n * @method isBigUint64Array\n * @since 0.6.0\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 BigUint64Array 类型，返回 true，否则返回 false\n */\nconst isBigUint64Array = (val) => {\n  return _type(val) === TYPES.BIG_UINT64_ARRAY\n}\n\nexport default isBigUint64Array\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据的数据类型是否为 BigInt 类型。\r\n * ========================================================================\r\n * @method isBigInt\r\n * @since 0.6.0\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 为 BigInt 类型，返回 true，否则返回 false\r\n */\r\nconst isBigInt = (val) => {\r\n  return _type(val) === TYPES.BIG_INT\r\n}\r\n\r\nexport default isBigInt\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Boolean 类型\r\n * ========================================================================\r\n * @method isBoolean\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Boolean 类型，则返回 true，否则返回 false\r\n */\r\nconst isBoolean = (val) => {\r\n  return _type(val) === TYPES.BOOLEAN\r\n}\r\n\r\nexport default isBoolean\r\n","import isFunction from './isFunction'\r\nimport isNativeFunction from './isNativeFunction'\r\n\r\n/**\r\n * 检测测试函数是否为构造函数\r\n * ========================================================================\r\n * @method isConstructor\r\n * @category Lang\r\n * @param {Function|Object} fn - 要测试的（构造）函数\r\n * @returns {Boolean} - fn 是构造函数，返回 true，否则返回 false;\r\n */\r\nconst isConstructor = (fn) => {\r\n  const proto = fn.prototype\r\n  let instance\r\n\r\n  if (!isFunction(fn) || !proto) {\r\n    return false\r\n  }\r\n\r\n  // 判断 fn 是否为 Promise 构造函数\r\n  if (isNativeFunction(fn) && proto?.then) {\r\n    instance = new fn((resolve, reject) => {})\r\n  } else {\r\n    instance = new fn()\r\n  }\r\n\r\n  // 判断 constructor\r\n  return (\r\n    (instance.constructor === fn && instance instanceof fn) ||\r\n    (instance.constructor === Object && instance instanceof Object)\r\n  )\r\n}\r\n\r\nexport default isConstructor\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 DataView 类型\r\n * ========================================================================\r\n * @method isDataView\r\n * @param {*} val - 要检测的数据\r\n * @return {Boolean} 'val' 是 DataView 类型，返回 true，否则返回 false\r\n */\r\nconst isDataView = (val) => {\r\n  return _type(val) === TYPES.DATA_VIEW\r\n}\r\n\r\nexport default isDataView\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据的数据类型是否为 Date 类型\r\n * ========================================================================\r\n * @method isDate\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 为 Date 类型，返回 true，否则返回 false\r\n */\r\nconst isDate = (val) => {\r\n  return (\r\n    _type(val) === TYPES.DATE &&\r\n    val.toString() !== 'Invalid Date' &&\r\n    !isNaN(val)\r\n  )\r\n}\r\n\r\nexport default isDate\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据的数据类型是否为 HTML 元素节点。\r\n * ========================================================================\r\n * @method isElement\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 为 HTML 元素节点，返回 true，否则返回 false\r\n */\r\nconst isElement = (val) => {\r\n  return _type(val) === TYPES.ELEMENT\r\n}\r\n\r\nexport default isElement\r\n","import isArray from './isArray'\r\n\r\n/**\r\n * 检测测试数据是否为空字数组\r\n * ========================================================================\r\n * @method isEmptyArray\r\n * @since 0.5.0\r\n * @param {Array} val - （必须）待检测的数据\r\n * @returns {Boolean} 'val' 是空数组，返回 true，否则返回 false\r\n */\r\nconst isEmptyArray = (val) => {\r\n  return isArray(val) && val.length === 0\r\n}\r\n\r\nexport default isEmptyArray\r\n","import isPlainObject from './isPlainObject'\r\nimport hasOwn from './hasOwn'\r\n\r\n/**\r\n * 检测测试数据是否为空（单体）对象\r\n * ========================================================================\r\n * @method isEmptyObject\r\n * @param {Object} obj - 要检测的数据\r\n * @returns {Boolean} 'val' 是空对象，返回 true，否则返回 false\r\n */\r\nconst isEmptyObject = (obj) => {\r\n  let prop\r\n\r\n  if (!isPlainObject(obj)) {\r\n    return false\r\n  }\r\n\r\n  for (prop in obj) {\r\n    /* istanbul ignore else */\r\n    if (hasOwn(obj, prop)) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport default isEmptyObject\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Error 类型\r\n * ========================================================================\r\n * @method isError\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Error 类型，返回 true，否则返回 false\r\n */\r\nconst isError = (val) => {\r\n  return _type(val) === TYPES.ERROR\r\n}\r\n\r\nexport default isError\r\n","import isInteger from './isInteger'\r\n\r\n/**\r\n * 检测测试数据的数据类型是否为偶数\r\n * ========================================================================\r\n * @method isEven\r\n * @param {Number} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是偶数，返回 true，否则返回 false\r\n */\r\nconst isEven = (val) => {\r\n  return isInteger(val) && val % 2 === 0\r\n}\r\n\r\nexport default isEven\r\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 DocumentFragment 文档碎片。\n * ========================================================================\n * @method isFragment\n * @since 0.6.0\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 DocumentFragment 文档碎片，返回 true，否则返回 false\n */\nconst isFragment = (val) => {\n  return _type(val) === TYPES.FRAGMENT\n}\n\nexport default isFragment\n","import isPlainObject from './isPlainObject'\r\n\r\n/**\r\n * 检测测试数据是否为空（单体）对象\r\n * ========================================================================\r\n * @method isHash\r\n * @alias isPlainObject\r\n * @since 0.4.0\r\n * @category Lang\r\n * @param {Object} obj - 要检测的数据\r\n * @returns {Boolean} 'val' 是普通对象，返回 true，否则返回 false\r\n */\r\nconst isHash = (obj) => {\r\n  return isPlainObject(obj)\r\n}\r\n\r\nexport default isHash\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测数据的是否为 HTMLNodeList 对象\r\n * ========================================================================\r\n * @method isHTMLCollection\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 HTMLNodeList 对象，返回 true，否则返回 false\r\n */\r\nconst isHTMLCollection = (val) => {\r\n  return _type(val) === TYPES.COLLECTION\r\n}\r\n\r\nexport default isHTMLCollection\r\n","import isNumber from './isNumber'\r\n/**\r\n * 检测测试数据是否为有效 length 值\r\n * =============================================================\r\n * @method isLength\r\n * @param {Number} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是有效 length 值，返回 true，否则返回 false\r\n */\r\nconst isLength = (val) => {\r\n  const MAX_SAFE_INTEGER = 9007199254740991\r\n\r\n  return isNumber(val) && val > -1 && val % 1 === 0 && val <= MAX_SAFE_INTEGER\r\n}\r\n\r\nexport default isLength\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Map 类型\r\n * ========================================================================\r\n * @method isMap\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Map 类型，返回 true，否则返回 false\r\n */\r\nconst isMap = (val) => {\r\n  return _type(val) === TYPES.MAP\r\n}\r\n\r\nexport default isMap\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 null\r\n * ========================================================================\r\n * @method isNull\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 为 null，返回 true，否则返回 false\r\n */\r\nconst isNull = (val) => {\r\n  return _type(val) === TYPES.NULL\r\n}\r\n\r\nexport default isNull\r\n","import isNumber from './isNumber'\r\nimport isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否是一个数字（只能是 number 类型或者 '123123' 这样的数字字符串）\r\n * ========================================================================\r\n * @method isNumeric\r\n * @category Lang\r\n * @param {Number|String} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是一个数字，返回 true，否则返回false\r\n */\r\nconst isNumeric = (val) => {\r\n  return (isNumber(val) || isString(val)) && !isNaN(val - parseFloat(val))\r\n}\r\n\r\nexport default isNumeric\r\n","import isInteger from './isInteger'\r\n\r\n/**\r\n * 检测测试数据的数据类型是否为奇数\r\n * ========================================================================\r\n * @method isOdd\r\n * @param {Number} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是奇数，返回 true，否则返回 false\r\n */\r\nconst isOdd = (val) => {\r\n  return isInteger(val) && val % 2 !== 0\r\n}\r\n\r\nexport default isOdd\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测是否为电话号码\r\n * ========================================================================\r\n * @method isPhoneNumber\r\n * @category Lang\r\n * @param {String} str - 要检测的数据\r\n * @returns {Boolean} 'val' 是 电话号码 格式，返回 true，否则返回 false\r\n *\r\n * @example\r\n * // 移动电话号码\r\n * isPhoneNumber(13901030304) // -> false\r\n * isPhoneNumber('1390103030a') // => false\r\n *\r\n * isPhoneNumber('+86 13901030304')\r\n * isPhoneNumber('13901030304')\r\n * isPhoneNumber('139-010-30304')\r\n * isPhoneNumber('139.010.30304')\r\n *\r\n * // 固定电话号码\r\n * isPhoneNumber('+86 84923296') // -> true\r\n * isPhoneNumber('027 84923296') // -> true\r\n * isPhoneNumber('(027) 84923296') // -> true\r\n * isPhoneNumber('(027)84923296') // -> true\r\n * isPhoneNumber('027-84923296') // -> true\r\n * isPhoneNumber('027.84923296') // -> true\r\n * isPhoneNumber('027 849-23296') // -> true\r\n * isPhoneNumber('027-849-23296') // -> true\r\n */\r\nconst isPhoneNumber = (str) => {\r\n  const pattern =\r\n    /^\\+?\\(?(\\d{2,3})?\\)?[-\\s.]?((\\d{3}[-\\s.]?\\d{4,6})|(\\d{11}))$/im\r\n  return isString(str) && pattern.test(str)\r\n}\r\n\r\nexport default isPhoneNumber\r\n","import _type from './_type'\r\nimport isObject from './isObject'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测数据是否为 Promise 对象\r\n * ========================================================================\r\n * @method isPromise\r\n * @since 1.3.0\r\n * @category Lang\r\n * @param {Object} val - 测试数据\r\n * @returns {Boolean} 'val' 是 Promise 对象，返回 true，否则返回 false\r\n */\r\nconst isPromise = (val) => {\r\n  return isObject(val) && _type(val) === TYPES.PROMISE\r\n}\r\n\r\nexport default isPromise\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为正则表达式\r\n * ========================================================================\r\n * @method isRegExp\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是正则表达式，返回 true，否则返回 false\r\n */\r\nconst isRegExp = (val) => {\r\n  return _type(val) === TYPES.REGEXP\r\n}\r\n\r\nexport default isRegExp\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Set 类型\r\n * ========================================================================\r\n * @method isSet\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Set 类型，返回 true，否则返回 false\r\n */\r\nconst isSet = (val) => {\r\n  return _type(val) === TYPES.SET\r\n}\r\n\r\nexport default isSet\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 Symbol 类型\r\n * ========================================================================\r\n * @method isSymbol\r\n * @category Lang\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 Symbol 类型，返回 true，否则返回 false\r\n */\r\nconst isSymbol = (val) => {\r\n  return _type(val) === TYPES.SYMBOL\r\n}\r\n\r\nexport default isSymbol\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为文本节点\r\n * ========================================================================\r\n * @method isTextNode\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是文本节点，返回 true，否则返回 false\r\n */\r\nconst isTextNode = (val) => {\r\n  const type = _type(val)\r\n  return type === TYPES.TEXT\r\n}\r\n\r\nexport default isTextNode\r\n","import _type from './_type'\r\n/**\r\n * 检测测试数据是否为 TypedArray 类型\r\n * ========================================================================\r\n * @method isTypedArray\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 type arrays 类型，返回 true，否则返回 false\r\n */\r\nconst isTypedArray = (val) => {\r\n  const type = _type(val)\r\n  const isTyped =\r\n    /^(?:Float(?:32|64)|(Int|Uint)(?:8|16|32)|Uint8Clamped|Big(Int|Uint)64)Array$/i\r\n  return isTyped.test(type)\r\n}\r\n\r\nexport default isTypedArray\r\n","import isString from './isString'\r\n\r\n/**\r\n * 判断字符串是否为有效的 URL 地址\r\n * ========================================================================\r\n * @method isURL\r\n * @category Lang\r\n * @param {String} str - 要检测的字符串\r\n * @returns {Boolean} 'val' 是有效的 URL 字符串格式，返回 true，否则返回 false\r\n */\r\nconst isURL = (str) => {\r\n  const protocol = '(https?:)?'\r\n  const user = '([^\\\\/\\\\?\\\\#\\\\:]+)'\r\n  const password = '(.+)'\r\n  const auth = '(' + user + ':' + password + '@)?'\r\n  const domain = '(([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*(\\\\.)?)+[a-z]{2,})'\r\n  const ip = '((\\\\d{1,3}\\\\.){3}\\\\d{1,3})'\r\n  const port = '(\\\\:\\\\d+)?'\r\n  const path = '(\\\\/[-a-z\\\\d%_.~+]*)*'\r\n  const search = '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'\r\n  const hash = '(\\\\#[-a-z\\\\d_]*)?'\r\n  const url =\r\n    '^' +\r\n    protocol +\r\n    '\\\\/\\\\/' +\r\n    auth +\r\n    '(' +\r\n    domain +\r\n    '|' +\r\n    ip +\r\n    ')' +\r\n    port +\r\n    path +\r\n    search +\r\n    hash +\r\n    '$'\r\n  const pattern = new RegExp(url, 'i')\r\n\r\n  return isString(str) && !!pattern.test(str)\r\n}\r\n\r\nexport default isURL\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为有效的数据\r\n * =============================================================\r\n * @method isValue\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是有效的数据，返回 true，否则返回 false\r\n */\r\nconst isValue = (val) => {\r\n  const type = _type(val)\r\n\r\n  switch (type) {\r\n    case TYPES.NUMBER:\r\n      return isFinite(val)\r\n    case TYPES.NULL:\r\n    case TYPES.UNDEFINED:\r\n      return false\r\n    default:\r\n      return !!type\r\n  }\r\n}\r\n\r\nexport default isValue\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 WeakMap 类型\r\n * ========================================================================\r\n * @method isWeakMap\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 WeakMap 类型，返回 true，否则返回 false\r\n */\r\nconst isWeakMap = (val) => {\r\n  return _type(val) === TYPES.WEAK_MAP\r\n}\r\n\r\nexport default isWeakMap\r\n","import _type from './_type'\r\nimport TYPES from './enum/types'\r\n\r\n/**\r\n * 检测测试数据是否为 WeakSet 类型\r\n * ========================================================================\r\n * @method isWeakSet\r\n * @param {*} val - 要检测的数据\r\n * @returns {Boolean} 'val' 是 WeakSet 类型，返回 true，否则返回 false\r\n */\r\nconst isWeakSet = (val) => {\r\n  return _type(val) === TYPES.WEAK_SET\r\n}\r\n\r\nexport default isWeakSet\r\n"],"names":["TYPES","OBJECTS","_type","val","type","Object","prototype","toString","apply","_typeof","name","tagName","nodeType","isNumber","isInteger","isNaN","Number","isFloat","isFinite","isInfinite","Infinity","isString","obj","isBlank","test","isBase64","length","isChinese","str","includePunctuation","toRegExp","range","pattern","map","rangeStart","rangeEnd","hexStart","hexEnd","join","RegExp","chineseIdeographs","concat","isEmail","isEmpty","isGuid","guid","replace","isIPAddress","isHex","TAGS","isJSON","_isTime","_isDate","Date","parse","_getExactTypeOfString","html","basic","full","trim","slice","tag","isHTML","isTime","isFunction","isPrototype","OP","Ctor","constructor","proto","isUndefined","hasOwn","prop","hasOwnProperty","call","isObject","isVNode","node","isXML","documentElement","ownerDocument","nodeName","isArray","Array","isArrayLike","isObjectLike","isNativeFunction","fn","isPlainObject","getPrototypeOf","is","_getExactTypeOfNumber","_getExactTypeOfObject","isArrayLikeObject","isArguments","isArrayBuffer","isInt8Array","isUint8Array","isUint8ClampedArray","isInt16Array","isUint16Array","isInt32Array","isUint32Array","isFloat32Array","isFloat64Array","isBigInt64Array","isBigUint64Array","isBigInt","isBoolean","isConstructor","instance","then","resolve","reject","isDataView","isDate","isElement","isEmptyArray","isEmptyObject","isError","isEven","isFragment","isHash","isHTMLCollection","isLength","isMap","isNull","isNumeric","parseFloat","isOdd","isPhoneNumber","isPromise","isRegExp","isSet","isSymbol","isTextNode","isTypedArray","isURL","isValue","isWeakMap","isWeakSet"],"mappings":"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C,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAGT,CAAC,MAAQ,SAcED,GAEEhB,KAAKI,EAAG,ECxHnBc,EAAWvC,GAGRkB,EAASlB,IADd,oKAC8BqB,KAAKrB,GCHjCwC,EAAWxC,GACRkB,EAASlB,IAAgB,KAARA,ECApByC,EAAUhB,IAMd,IAAIiB,EAEJ,QAAKxB,EAASO,KAIdiB,EAAOjB,EAAIkB,QAAQ,UAAW,IAV5B,sFAYwBtB,KAAKqB,IAV7B,kFAU4DrB,KAAKqB,GAAI,ECfnEE,EAAenB,GAKZP,EAASO,KADd,4EAC4BJ,KAAKI,IAHjC,6kBAG8CJ,KAAKI,ICNjDoB,EAAS7C,GAENkB,EAASlB,IADG,4CACgBqB,KAAKrB,GCVpC8C,EAAO,CACX,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,OACA,WACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,UACA,MACA,WACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,SACA,SACA,UACA,SACA,OACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,QACA,KACA,QACA,IACA,KACA,MACA,QACA,OC7GIC,EAAU/C,MACTkB,EAASlB,IAAQoB,EAAQpB,KAASA,KASvCA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"}