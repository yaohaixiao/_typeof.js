{"version":3,"file":"types.min.js","sources":["../../enum/types.js","../../enum/objects.js","../../_type.js","../../isNumber.js","../../isInteger.js","../../isFloat.js","../../isInfinite.js","../../isString.js","../../isBlank.js","../../isChinese.js","../../isEmail.js","../../isEmpty.js","../../isGuid.js","../../enum/tags.js","../../isJSON.js","../../isFunction.js","../../isPrototype.js","../../_isTime.js","../../_isDate.js","../../isXML.js","../../is.js","../../isHTML.js","../../trim.js","../../isTime.js","../../isArray.js","../../isArrayLike.js","../../isObject.js","../../isObjectLike.js","../../isInt8Array.js","../../isNativeFunction.js","../../isUndefined.js","../../hasOwn.js","../../isPlainObject.js","../../types.js","../../isArrayLikeObject.js","../../isArguments.js","../../isArrayBuffer.js","../../isUint8Array.js","../../isUint8ClampedArray.js","../../isInt16Array.js","../../isUint16Array.js","../../isInt32Array.js","../../isUint32Array.js","../../isFloat32Array.js","../../isFloat64Array.js","../../isBigInt64Array.js","../../isBigUint64Array.js","../../isBigInt.js","../../isBase64.js","../../isBoolean.js","../../isConstructor.js","../../isDataView.js","../../isDate.js","../../isElement.js","../../isEmptyArray.js","../../isEmptyObject.js","../../isError.js","../../isEven.js","../../isFragment.js","../../isHash.js","../../isHex.js","../../isHTMLCollection.js","../../isIPAddress.js","../../isLength.js","../../isMap.js","../../isNull.js","../../isNumeric.js","../../isOdd.js","../../isPhoneNumber.js","../../isPromise.js","../../isRegExp.js","../../isSet.js","../../isSymbol.js","../../isTextNode.js","../../isTypedArray.js","../../isURL.js","../../isValue.js","../../isVNode.js","../../isWeakMap.js","../../isWeakSet.js"],"sourcesContent":["// 能够识别的数据类型名称枚举值\nconst TYPES = {\n  /* ===== Primitive data types ===== */\n  BIG_INT: 'bigint',\n  BOOLEAN: 'boolean',\n  NULL: 'null',\n  NUMBER: 'number',\n  UNDEFINED: 'undefined',\n  STRING: 'string',\n  SYMBOL: 'symbol',\n  /* ===== Keyed Collections ===== */\n  SET: 'set',\n  WEAK_SET: 'weakset',\n  MAP: 'map',\n  WEAK_MAP: 'weakmap',\n  /* ===== Array ===== */\n  ARRAY: 'array',\n  ARGUMENTS: 'arguments',\n  /* ===== Typed Arrays ===== */\n  DATA_VIEW: 'dataview',\n  ARRAY_BUFFER: 'arraybuffer',\n  INT8_ARRAY: 'int8array',\n  UNIT8_ARRAY: 'uint8array',\n  UNIT8_CLAMPED_ARRAY: 'uint8clampedarray',\n  INT16_ARRAY: 'int16array',\n  UNIT16_ARRAY: 'uint16array',\n  INT32_ARRAY: 'int32array',\n  UNIT32_ARRAY: 'uint32array',\n  FLOAT32_ARRAY: 'float32array',\n  FLOAT64_ARRAY: 'float64array',\n  BIG_INT64_ARRAY: 'bigint64array',\n  BIG_UINT64_ARRAY: 'biguint64array',\n  /* ===== Object ===== */\n  OBJECT: 'object',\n  COLLECTION: 'collection',\n  DATE: 'date',\n  ELEMENT: 'element',\n  ERROR: 'error',\n  FRAGMENT: 'fragment',\n  FUNCTION: 'function',\n  PROMISE: 'promise',\n  REGEXP: 'regexp',\n  TEXT: 'text'\n}\n\nexport default TYPES\n","import TYPES from './types'\n\n// Object.prototype.toString() 输出的类型名称枚举值\nconst OBJECTS = {\n  /* ===== Primitive data types ===== */\n  '[object Null]': TYPES.NULL,\n  /* ===== Keyed Collections ===== */\n  '[object Set]': TYPES.SET,\n  '[object WeakSet]': TYPES.WEAK_SET,\n  '[object Map]': TYPES.MAP,\n  '[object WeakMap]': TYPES.WEAK_MAP,\n  /* ===== Array ===== */\n  '[object Array]': TYPES.ARRAY,\n  '[object Arguments]': TYPES.ARGUMENTS,\n  /* ===== Typed Arrays ===== */\n  '[object DataView]': TYPES.DATA_VIEW,\n  '[object ArrayBuffer]': TYPES.ARRAY_BUFFER,\n  '[object Int8Array]': TYPES.INT8_ARRAY,\n  '[object Uint8Array]': TYPES.UNIT8_ARRAY,\n  '[object Uint8ClampedArray]': TYPES.UNIT8_CLAMPED_ARRAY,\n  '[object Int16Array]': TYPES.INT16_ARRAY,\n  '[object Uint16Array]': TYPES.UNIT16_ARRAY,\n  '[object Int32Array]': TYPES.INT32_ARRAY,\n  '[object Uint32Array]': TYPES.UNIT32_ARRAY,\n  '[object Float32Array]': TYPES.FLOAT32_ARRAY,\n  '[object Float64Array]': TYPES.FLOAT64_ARRAY,\n  '[object BigInt64Array]': TYPES.BIG_INT64_ARRAY,\n  '[object BigUint64Array]': TYPES.BIG_UINT64_ARRAY,\n  /* ===== Object ===== */\n  '[object Object]': TYPES.OBJECT,\n  '[object Boolean]': TYPES.OBJECT,\n  '[object String]': TYPES.OBJECT,\n  '[object Number]': TYPES.OBJECT,\n  '[object Date]': TYPES.DATE,\n  '[object Error]': TYPES.ERROR,\n  '[object DocumentFragment]': TYPES.FRAGMENT,\n  '[object Function]': TYPES.FUNCTION,\n  '[object NodeList]': TYPES.COLLECTION,\n  '[object Promise]': TYPES.PROMISE,\n  '[object RegExp]': TYPES.REGEXP,\n  '[object Text]': TYPES.TEXT\n}\n\nexport default OBJECTS\n","import TYPES from './enum/types'\nimport OBJECTS from './enum/objects'\n\n/**\n * 检测数据类型，返回检测数据类型的字符串\n * ========================================================================\n * @method _type\n * @param {*} val - 要检测的任意值\n * @returns {String}\n */\nconst _type = (val) => {\n  const type = Object.prototype.toString.apply(val)\n  const _typeof = typeof val\n  let name\n\n  // HTMLElement\n  if (val?.tagName && val.nodeType === 1) {\n    name = TYPES.ELEMENT\n  } else {\n    /* ===== 原始值类型（Primitive data types） ===== */\n    switch (_typeof) {\n      case 'bigint':\n        name = TYPES.BIG_INT\n        break\n      case 'string':\n        name = TYPES.STRING\n        break\n      case 'number':\n        name = TYPES.NUMBER\n        break\n      case 'boolean':\n        name = TYPES.BOOLEAN\n        break\n      case 'undefined':\n        name = TYPES.UNDEFINED\n        break\n      case 'symbol':\n        name = TYPES.SYMBOL\n        break\n      // 对象（引用）类型的数据\n      default:\n        name = OBJECTS[type]\n        break\n    }\n  }\n\n  return name || type\n}\n\nexport default _type\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Number 类型\n * ========================================================================\n * @method isNumber\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Number 类型，返回 true，否则返回 false\n */\nconst isNumber = (val) => {\n  return _type(val) === TYPES.NUMBER\n}\n\nexport default isNumber\n","import isNumber from './isNumber'\n\n/**\n * 检测测试数据是否为整数\n * ========================================================================\n * @method isInteger\n * @category Lang\n * @param {Number} val - 要检测的数据\n * @returns {Boolean} 'val' 是整数，返回 true，否则返回 false\n */\nconst isInteger = (val) => {\n  return isNumber(val) && !isNaN(val) && Number(val) === val && val % 1 === 0\n}\n\nexport default isInteger\n","import isNumber from './isNumber'\nimport isInteger from './isInteger'\n\n/**\n * 检测测试数据是否为整数\n * ========================================================================\n * @method isFloat\n * @category Lang\n * @param {Number} val - 要检测的数据\n * @returns {Boolean} 'val' 是整数，返回 true，否则返回 false\n */\nfunction isFloat(val) {\n  return (\n    isNumber(val) &&\n    !isNaN(val) &&\n    isFinite(val) &&\n    !isInteger(val) &&\n    Number(val) === val &&\n    val % 1 !== 0\n  )\n}\n\nexport default isFloat\n","import isNumber from './isNumber'\n\n/**\n * 检测测试数据的数据是正无穷或者负无穷\n * ========================================================================\n * @method isInfinite\n * @param {Number} val - 要检测的数据\n * @returns {Boolean} 'val' 是正无穷或者负无穷，返回 true，否则返回 false\n */\nconst isInfinite = (val) => {\n  return isNumber(val) && (val === Infinity || val === -Infinity)\n}\n\nexport default isInfinite\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为字符串\n * ========================================================================\n * @method isString\n * @category Lang\n * @param {*} obj - 要检测的数据\n * @returns {Boolean} 'val' 是字符串，返回 true，否则返回 false\n */\nconst isString = (obj) => {\n  return _type(obj) === TYPES.STRING\n}\n\nexport default isString\n","import isString from './isString'\n\n/**\n * 检测测试数据是否只包空格\n * ========================================================================\n * @method isBlank\n * @param {String} val - 要检测的数据\n * @returns {Boolean} 'val' 只包含空格，返回 true，否则返回 false\n */\nfunction isBlank(val) {\n  if (!isString(val)) {\n    return false\n  }\n\n  return /^\\s*$/.test(val)\n}\n\nexport default isBlank\n","import isString from './isString'\n\n/**\n * 检测字符串是否为中文字符\n * ========================================================================\n * Wiki 介绍中文字符包含以下内容：\n *\n * 1. 中文汉字\n * 2. 象形文字扩展 A-H\n * 3. 兼容象形文字符\n * 4. 兼容表意文字增补字符\n * 5. 中文标点符号\n * 6. 兼容标点符号\n *\n * 其中：\n *\n * 兼容象形文字符：[0xf900, 0xfaff],（https://en.wikipedia.org/wiki/CJK_Compatibility_Ideographs）和\n * 兼容表意文字增补字符：[0x2f800, 0x2fa1f]（https://en.wikipedia.org/wiki/CJK_Compatibility_Ideographs_Supplement）\n *\n * 只是看上去像汉字，因此在 isChinese() 方法中也没有纳入到汉字字符\n * ========================================================================\n * @method isChinese\n * @since 1.2.0\n * @param {String} str - （必须）检测字符串\n * @param {Boolean} [includePunctuation] - （可选）是否包含标点符号：默认值：true\n * @returns {boolean} - ‘val’ 是中文字符，返回 true，否则返回 false;\n */\nconst isChinese = (str, includePunctuation = true) => {\n  // 转换成正则表达式\n  const toRegExp = (range) => {\n    const pattern = range\n      .map((range) => {\n        const rangeStart = range[0]\n        const rangeEnd = range[1]\n        const hexStart = rangeStart.toString(16)\n        const hexEnd = rangeEnd.toString(16)\n\n        if (rangeStart === rangeEnd) {\n          return `\\\\u{${hexStart}}`\n        }\n        return `[\\\\u{${hexStart}}-\\\\u{${hexEnd}}]`\n      })\n      .join('|')\n\n    return new RegExp(`^(?:${pattern})+$`, 'u')\n  }\n  // 文字\n  // https://en.wikipedia.org/wiki/CJK_Unified_Ideographs\n  const chineseIdeographs = [\n    // 中文汉字\n    [0x4e00, 0x9fff],\n\n    // 象形文字扩展 A - H\n    [0x3400, 0x4dbf],\n    [0x20000, 0x2a6df],\n    [0x2a700, 0x2b73f],\n    [0x2b740, 0x2b81f],\n    [0x2b820, 0x2ceaf],\n    [0x2ceb0, 0x2ebef],\n    [0x30000, 0x3134f],\n    [0x31350, 0x323af]\n  ]\n  // 标点符号\n  const chinesePunctuations = [\n    // ，\n    [0xff0c, 0xff0c],\n    // 。\n    [0x3002, 0x3002],\n    // ·\n    [0x00b7, 0x00b7],\n    // ×\n    [0x00d7, 0x00d7],\n    // —\n    [0x2014, 0x2014],\n    // ‘\n    [0x2018, 0x2018],\n    // ’\n    [0x2019, 0x2019],\n    // “\n    [0x201c, 0x201c],\n    // ”\n    [0x201d, 0x201d],\n    // …\n    [0x2026, 0x2026],\n    // 、\n    [0x3001, 0x3001],\n    // 《\n    [0x300a, 0x300a],\n    // 》\n    [0x300b, 0x300b],\n    // 『\n    [0x300e, 0x300e],\n    // 』\n    [0x300f, 0x300f],\n    // 【\n    [0x3010, 0x3010],\n    // 】\n    [0x3011, 0x3011],\n    // ！\n    [0xff01, 0xff01],\n    // （\n    [0xff08, 0xff08],\n    // ）\n    [0xff09, 0xff09],\n    // ：\n    [0xff1a, 0xff1a],\n    // ；\n    [0xff1b, 0xff1b],\n    // ？\n    [0xff1f, 0xff1f],\n    // ～\n    [0xff5e, 0xff5e],\n    // 兼容性标点符号\n    // https://en.wikipedia.org/wiki/CJK_Compatibility_Forms\n    [0xfe30, 0xfe4f]\n  ]\n  const asciiChars = /\\w+/\n\n  if (!isString(str)) {\n    return false\n  }\n\n  if (asciiChars.test(str)) {\n    return false\n  }\n\n  const pattern = includePunctuation\n    ? toRegExp(chineseIdeographs.concat(chinesePunctuations))\n    : toRegExp(chineseIdeographs)\n\n  return pattern.test(str)\n}\n\nexport default isChinese\n","import isString from './isString'\n\n/**\n * 检测是否为正确的 Email 邮箱地址格式\n * ========================================================================\n * @method isEmail\n * @category Lang\n * @param {String} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Email 邮箱地址格式，返回 true，否则返回 false\n */\nconst isEmail = (val) => {\n  const pattern =\n    /^([a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?)$/\n  return isString(val) && pattern.test(val)\n}\n\nexport default isEmail\n","import isString from './isString'\n\n/**\n * 检测测试数据是否为空字符串\n * ========================================================================\n * @method isEmpty\n * @category Lang\n * @param {String} val - 要检测的数据\n * @returns {Boolean} 'val' 是空字符串，返回 true，否则返回 false\n */\nconst isEmpty = (val) => {\n  return isString(val) && val === ''\n}\n\nexport default isEmpty\n","import isString from './isString'\n\n/**\n * 检测测试数据是否为 Guid 格式字符串\n * ========================================================================\n * @method isGuid\n * @since 1.4.0\n * @category Lang\n * @param {String} str - 待检测数据（字符串）\n * @returns {Boolean} 'val' 是 Guid 格式字符串，返回 true，否则返回 false\n */\nconst isGuid = (str) => {\n  const patternWithHyphens =\n    /^{?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}}?$/gi\n  const patternWithoutHyphens =\n    /^{?[0-9a-fA-F]{8}[0-9a-fA-F]{4}[0-9a-fA-F]{4}[0-9a-fA-F]{4}[0-9a-fA-F]{12}}?$/gi\n\n  let guid\n\n  if (!isString(str)) {\n    return false\n  }\n\n  guid = str.replace(/^[{}]$/i, '')\n\n  return patternWithHyphens.test(guid) || patternWithoutHyphens.test(guid)\n}\n\nexport default isGuid\n","// HTML 合法的标签\nconst TAGS = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'math',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rb',\n  'rp',\n  'rt',\n  'rtc',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'search',\n  'section',\n  'select',\n  'slot',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'svg',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr'\n]\n\nexport default TAGS\n","import isString from './isString'\nimport isBlank from './isBlank'\n\n/**\n * 检测测试数据是否为 JSON 格式字符串数据\n * ========================================================================\n * @method isJSON\n * @param {String} val - 要检测的数据\n * @returns {Boolean} 'val' 是 JSON 格式字符串，返回 true，否则返回 false\n */\nconst isJSON = (val) => {\n  if (!isString(val) || isBlank(val) || !val) {\n    return false\n  }\n\n  val = val.replace(/\\\\(?:([\"\\\\/bfnrt])|(u[0-9a-fA-F]{4}))/g, '@')\n  val = val.replace(\n    /\"[\\w\\s]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?/g,\n    ']'\n  )\n  val = val.replace(/(?:^|:|,)(?:\\s*\\[)+/g, '')\n\n  return /^[\\],:{}\\s]*$/.test(val)\n}\n\nexport default isJSON\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Function 类型\n * ========================================================================\n * @method isFunction\n * @category Lang\n * @param {*} val - （必须）待检测的数据\n * @returns {Boolean} 'val' 是 Function 类型，返回 true，否则返回 false\n */\nconst isFunction = (val) => {\n  const type = _type(val)\n  return type === TYPES.FUNCTION\n}\n\nexport default isFunction\n","import isFunction from './isFunction'\n\n/**\n * 判断是否为 prototype 对象\n * ========================================================================\n * @method isPrototype\n * @param {Function|Object} val - 要检测的数据\n * @returns {Boolean} 'val' 是 prototype 对象，返回 true，否则返回 false\n */\nconst isPrototype = (val) => {\n  const OP = Object.prototype\n  const Ctor = val ? val.constructor : null\n  const proto = (isFunction(Ctor) && Ctor.prototype) || OP\n\n  return val === proto\n}\n\nexport default isPrototype\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为有效的时间（字符串）\r\n * ========================================================================\r\n * @method _isTime\r\n * @private\r\n * @param {String} str - 待检测数据（字符串）\r\n * @returns {Boolean}\r\n */\r\nconst _isTime = (str) => {\r\n  const pattern12Hours = /^(0?[1-9]|1[0-2]):[0-5]\\d(\\s(am|pm|AM|PM))?$/\r\n  const pattern24Hours = /^(0?[1-9]|2[0-3]):([0-5]\\d){1,2}$/\r\n\r\n  return isString(str) && (pattern12Hours.test(str) || pattern24Hours.test(str))\r\n}\r\n\r\nexport default _isTime\r\n","import isString from './isString'\r\n\r\n/**\r\n * 检测测试数据是否为有效的日期（字符串）\r\n * ========================================================================\r\n * @method _isDate\r\n * @private\r\n * @param {String} str - 待检测数据（字符串）\r\n * @returns {Boolean}\r\n */\r\nconst _isDate = (str) => {\r\n  return isString(str) && !isNaN(Date.parse(str))\r\n}\r\n\r\nexport default _isDate\r\n","/**\n * 检测是否为 XML 文档\n * ========================================================================\n * @method isXML\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 XML 文档，返回 true，否则返回 false\n */\nconst isXML = (val) => {\n  const documentElement = val && (val.ownerDocument || val).documentElement\n  return documentElement ? documentElement.nodeName !== 'HTML' : false\n}\n\nexport default isXML\n","import _type from './_type'\nimport isInteger from './isInteger'\nimport isFloat from './isFloat'\nimport isInfinite from './isInfinite'\nimport isBlank from './isBlank'\nimport isChinese from './isChinese'\nimport isEmail from './isEmail'\nimport isEmpty from './isEmpty'\nimport isGuid from './isGuid'\nimport isHTML from './isHTML'\nimport isJSON from './isJSON'\nimport isPrototype from './isPrototype'\nimport isTime from './isTime'\nimport isXML from './isXML'\n\n/**\n * （私有方法）获取确切的数值类型\n * ========================================================================\n * @method _getExactTypeOfNumber\n * @private\n * @param {Number} val - 要检测的数值\n * @returns {String} - 返回数值类型：integer、float、infinite\n */\nconst _getExactTypeOfNumber = (val) => {\n  let name = 'number'\n\n  if (isInteger(val)) {\n    name = 'integer'\n  } else if (isFloat(val)) {\n    name = 'float'\n  } else if (isInfinite(val)) {\n    name = 'infinite'\n  }\n\n  return name\n}\n\n/**\n * （私有方法）获取确切的字符串类型\n * ========================================================================\n * @method _getExactTypeOfString\n * @private\n * @param {String} val - 要检测的字符串\n * @returns {String} 返回字符串类型：blank、chinese、email、empty... 等等\n */\nconst _getExactTypeOfString = (val) => {\n  let name = 'string'\n\n  if (isEmpty(val)) {\n    name = 'empty'\n  } else if (isBlank(val)) {\n    name = 'blank'\n  } else if (isChinese(val)) {\n    name = 'chinese'\n  } else if (isEmail(val)) {\n    name = 'email'\n  } else if (isGuid(val)) {\n    name = 'guid'\n  } else if (isHTML(val)) {\n    name = 'html'\n  } else if (isJSON(val)) {\n    name = 'json'\n  } else if (isTime(val)) {\n    name = 'time'\n  }\n\n  return name\n}\n\nconst _getExactTypeOfObject = (val) => {\n  let name = 'object'\n\n  if (isXML(val)) {\n    name = 'xml'\n  } else if (isPrototype(val)) {\n    name = 'prototype'\n  }\n\n  return name\n}\n\n/**\n * 检测数据类型，返回检测数据类型的字符串\n * ========================================================================\n * @method is\n * @category Lang\n * @see _type\n * @param {*} val - 要检测的任意值\n * @returns {String} 返回确切的数据类型名称\n */\nconst is = (val) => {\n  const type = _type(val)\n  let name\n\n  switch (type) {\n    case 'number':\n      name = _getExactTypeOfNumber(val)\n      break\n    case 'string':\n      name = _getExactTypeOfString(val)\n      break\n    case 'object':\n      name = _getExactTypeOfObject(val)\n      break\n    default:\n      name = type\n      break\n  }\n\n  return name\n}\n\nexport default is\n","import isString from './isString'\nimport trim from './trim'\nimport TAGS from './enum/tags'\n\n/**\n * 检测测试数据是否为合法的 HTML 代码\n * ========================================================================\n * @method isHTML\n * @since 0.5.0\n * @category Lang\n * @see https://github.com/sindresorhus/html-tags\n * @see https://github.com/sindresorhus/is-html\n * @param {String} str - 要检测的数据\n * @returns {Boolean} 'val' 为合法的 HTML 代码，返回 true，否则返回 false\n */\nconst isHTML = (str) => {\n  let html\n  let basic\n  let full\n\n  if (!isString(str)) {\n    return false\n  }\n\n  // 为了提高性能，我们将其限制在合理的长度内。\n  html = trim(str).slice(0, 1000)\n  basic = /\\s*<!doctype html>|<html\\b[^>]*>|<body\\b[^>]*>|<x-[^>]+>/i\n  full = new RegExp(TAGS.map((tag) => `<${tag}\\\\b[^>]*>`).join('|'), 'i')\n\n  return basic.test(html) || full.test(html)\n}\n\nexport default isHTML\n","const trim = (str) => {\n  /* istanbul ignore else */\n  if (str.trim) {\n    return str.trim()\n  }\n\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nexport default trim\n","import _isTime from './_isTime'\nimport _isDate from './_isDate'\n\n/**\n * 检测测试数据是否为有效的时间（字符串）\n * ========================================================================\n * @method isTime\n * @since 1.4.0\n * @param {String} str - （必须）待测试的字符串\n * @param {String} [type] - 测试的时间类型：\n *                          time - 时间；\n *                          date - 日期；\n *                          不传 - 时间或者日期皆可\n * @returns {Boolean} 'val' 是有效的时间（字符串），返回 true，否则返回 false\n */\nconst isTime = (str, type) => {\n  switch (type) {\n    case 'time':\n      return _isTime(str)\n    case 'date':\n      return _isDate(str)\n    default:\n      return _isTime(str) || _isDate(str)\n  }\n}\n\nexport default isTime\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Array 类型\n * ========================================================================\n * @method isArray\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} - 'val' 是 Array 类型，返回 true，否则返回 false\n */\nconst isArray = (val) => {\n  return Array.isArray ? Array.isArray(val) : _type(val) === TYPES.ARRAY\n}\n\nexport default isArray\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为类似数组（array、arguments 对象或者\n * HTMLNodeList 对象）类型。\n * ========================================================================\n * @method isArrayLike\n * @param {*} val - 要检测是的数据\n * @returns {Boolean} 'val' 是 array、arguments 或者 HTMLNodeList 类型返回 true，否则返回 false\n */\nconst isArrayLike = (val) => {\n  const type = _type(val)\n\n  return (\n    type === TYPES.ARRAY ||\n    type === TYPES.ARGUMENTS ||\n    type === TYPES.COLLECTION\n  )\n}\n\nexport default isArrayLike\n","import isFunction from './isFunction'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为对象\n * ========================================================================\n * @method isObject\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为对象，返回 true，否则返回 false\n */\nconst isObject = (val) => {\n  const type = typeof val\n\n  return !!(val && (type === TYPES.OBJECT || isFunction(val)))\n}\n\nexport default isObject\n","import isObject from './isObject'\n\n/**\n * 检测测试数据是否为类似 Object 类型\n * ========================================================================\n * @method isObjectLike\n * @param {Object} val - 要检测的数据\n * @returns {Boolean} 'val' 是类似 Object 类型，返回 true，否则返回 false\n */\nconst isObjectLike = (val) => {\n  return isObject(val) && val !== null\n}\n\nexport default isObjectLike\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Int8Array 的数组\n * ========================================================================\n * methods isInt8Array\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Int32Array 类型，返回 true，否则返回 false\n */\nconst isInt8Array = (val) => {\n  return _type(val) === TYPES.INT8_ARRAY\n}\n\nexport default isInt8Array\n","import isFunction from './isFunction'\n\n/**\n * 检测测试数据是否为 JavaScript 内置函数\n * ========================================================================\n * @method isNativeFunction\n * @param {Function|Object} fn - 要测试的函数\n * @returns {Boolean} - fn 是内置函数，返回 true，否则返回 false;\n */\nconst isNativeFunction = (fn) => {\n  return isFunction(fn) && /\\{\\s*\\[native code\\]\\s*\\}/.test('' + fn)\n}\n\nexport default isNativeFunction\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否 undefined（未定义）\n * ========================================================================\n * @method isUndefined\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 undefined（未定义），返回 true，否则返回 false\n */\nconst isUndefined = (val) => {\n  return _type(val) === TYPES.UNDEFINED\n}\n\nexport default isUndefined\n","import isUndefined from './isUndefined'\n\n/**\n * 检测对象自身属性中是否具有指定的属性。\n * ========================================================================\n * @method hasOwn\n * @param {Object} obj - （必须）检测的目标对象\n * @param {String} prop - （必须）属性名\n * @returns {Boolean}\n */\nconst hasOwn = (obj, prop) => {\n  const hasOwnProperty = Object.prototype.hasOwnProperty\n\n  if (hasOwnProperty) {\n    // 不建议直接实用对象从原型链继承的 hasOwnProperty() 方法\n    // 所以采用直接调用 Object.prototype.hasOwnProperty() 方法\n    return hasOwnProperty.call(obj, prop)\n  }\n\n  return (\n    // 从对象构造函数的原型链继承的同名属性不算 obj 自身的属性\n    !isUndefined(obj[prop]) && obj.constructor.prototype[prop] !== obj[prop]\n  )\n}\n\nexport default hasOwn\n","import isObject from './isObject'\nimport hasOwn from './hasOwn'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为普通对象\n * ========================================================================\n * @method isPlainObject\n * @param {Object} val - 要检测的数据\n * @returns {Boolean} 'val' 是普通对象，返回 true，否则返回 false\n */\nconst isPlainObject = (val) => {\n  const toString = Object.prototype.toString\n  let proto\n  let Ctor\n\n  // Detect obvious negatives\n  if (!isObject(val)) {\n    return false\n  }\n\n  proto = val.prototype\n\n  if (!proto) {\n    return true\n  }\n\n  Ctor = hasOwn(proto, 'constructor') && proto.constructor\n\n  return (\n    typeof Ctor === TYPES.FUNCTION &&\n    toString.call(Ctor) === {}.hasOwnProperty.toString.call(Object)\n  )\n}\n\nexport default isPlainObject\n","import is from './is'\nimport isArray from './isArray'\nimport isArrayLike from './isArrayLike'\nimport isArrayLikeObject from './isArrayLikeObject'\nimport isArguments from './isArguments'\nimport isArrayBuffer from './isArrayBuffer'\nimport isInt8Array from './isInt8Array'\nimport isUint8Array from './isUint8Array'\nimport isUint8ClampedArray from './isUint8ClampedArray'\nimport isInt16Array from './isInt16Array'\nimport isUint16Array from './isUint16Array'\nimport isInt32Array from './isInt32Array'\nimport isUint32Array from './isUint32Array'\nimport isFloat32Array from './isFloat32Array'\nimport isFloat64Array from './isFloat64Array'\nimport isBigInt64Array from './isBigInt64Array'\nimport isBigUint64Array from './isBigUint64Array'\nimport isBigInt from './isBigInt'\nimport isBase64 from './isBase64'\nimport isBlank from './isBlank'\nimport isBoolean from './isBoolean'\nimport isConstructor from './isConstructor'\nimport isDataView from './isDataView'\nimport isDate from './isDate'\nimport isElement from './isElement'\nimport isEmail from './isEmail'\nimport isEmpty from './isEmpty'\nimport isEmptyArray from './isEmptyArray'\nimport isEmptyObject from './isEmptyObject'\nimport isError from './isError'\nimport isEven from './isEven'\nimport isFloat from './isFloat'\nimport isFragment from './isFragment'\nimport isFunction from './isFunction'\nimport isGuid from './isGuid'\nimport isHash from './isHash'\nimport isHex from './isHex'\nimport isHTMLCollection from './isHTMLCollection'\nimport isInfinite from './isInfinite'\nimport isInteger from './isInteger'\nimport isIPAddress from './isIPAddress'\nimport isJSON from './isJSON'\nimport isLength from './isLength'\nimport isMap from './isMap'\nimport isNativeFunction from './isNativeFunction'\nimport isNull from './isNull'\nimport isNumber from './isNumber'\nimport isNumeric from './isNumeric'\nimport isObject from './isObject'\nimport isObjectLike from './isObjectLike'\nimport isOdd from './isOdd'\nimport isChinese from './isChinese'\nimport isPhoneNumber from './isPhoneNumber'\nimport isPlainObject from './isPlainObject'\nimport isPromise from './isPromise'\nimport isPrototype from './isPrototype'\nimport isRegExp from './isRegExp'\nimport isSet from './isSet'\nimport isString from './isString'\nimport isSymbol from './isSymbol'\nimport isTextNode from './isTextNode'\nimport isTypedArray from './isTypedArray'\nimport isUndefined from './isUndefined'\nimport isURL from './isURL'\nimport isValue from './isValue'\nimport isVNode from './isVNode'\nimport isWeakMap from './isWeakMap'\nimport isWeakSet from './isWeakSet'\nimport isXML from './isXML'\n\nconst Types = {\n  is,\n  isArray,\n  isArrayLike,\n  isArrayLikeObject,\n  isArguments,\n  isArrayBuffer,\n  isInt8Array,\n  isUint8Array,\n  isUint8ClampedArray,\n  isInt16Array,\n  isUint16Array,\n  isInt32Array,\n  isUint32Array,\n  isFloat32Array,\n  isFloat64Array,\n  isBigInt64Array,\n  isBigUint64Array,\n  isBigInt,\n  isBase64,\n  isBlank,\n  isBoolean,\n  isConstructor,\n  isDataView,\n  isDate,\n  isElement,\n  isEmail,\n  isEmpty,\n  isEmptyArray,\n  isEmptyObject,\n  isError,\n  isEven,\n  isFloat,\n  isFragment,\n  isFunction,\n  isGuid,\n  isHash,\n  isHex,\n  isHTMLCollection,\n  isInfinite,\n  isInteger,\n  isIPAddress,\n  isJSON,\n  isLength,\n  isMap,\n  isNativeFunction,\n  isNull,\n  isNumber,\n  isNumeric,\n  isObject,\n  isObjectLike,\n  isOdd,\n  isChinese,\n  isPhoneNumber,\n  isPlainObject,\n  isPromise,\n  isPrototype,\n  isRegExp,\n  isSet,\n  isString,\n  isSymbol,\n  isTextNode,\n  isTypedArray,\n  isUndefined,\n  isURL,\n  isValue,\n  isVNode,\n  isWeakMap,\n  isWeakSet,\n  isXML\n}\n\nexport default Types\n","import isArrayLike from './isArrayLike'\nimport isObjectLike from './isObjectLike'\n\n/**\n * 检测测试数据是否为 ArrayLike 的对象数据\n * ========================================================================\n * @method isArrayLikeObject\n * @param {Object|Array} val - 要检测的数据\n * @returns {Boolean} ‘val’ 是类似 Array 类型对象，返回 true，否则返回 false;\n */\nconst isArrayLikeObject = (val) => {\n  return isObjectLike(val) && isArrayLike(val)\n}\n\nexport default isArrayLikeObject\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 arguments 对象\n * ========================================================================\n * @method isArguments\n * @param {*} val - 要检测的数据\n * @return {Boolean} ‘val’ 是 Arguments 对象，返回 true，否则返回 false;\n */\nfunction isArguments(val) {\n  return _type(val) === TYPES.ARGUMENTS\n}\n\nexport default isArguments\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 ArrayBuffer 类型\n * ========================================================================\n * @method isArrayBuffer\n * @category Lang\n * @param {*} val\n * @return {Boolean} ‘val’ 是 isArrayBuffer 类型，返回 true，否则返回 false\n */\nfunction isArrayBuffer(val) {\n  return _type(val) === TYPES.ARRAY_BUFFER\n}\n\nexport default isArrayBuffer\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Uint8Array 的数组\n * ========================================================================\n * methods isUint8Array\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Uint8Array 类型，返回 true，否则返回 false\n */\nconst isUint8Array = (val) => {\n  return _type(val) === TYPES.UNIT8_ARRAY\n}\n\nexport default isUint8Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Uint8ClampedArray 的数组\n * ========================================================================\n * methods isUint8ClampedArray\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Uint8ClampedArray 类型，返回 true，否则返回 false\n */\nconst isUint8ClampedArray = (val) => {\n  return _type(val) === TYPES.UNIT8_CLAMPED_ARRAY\n}\n\nexport default isUint8ClampedArray\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Int16Array 的数组\n * ========================================================================\n * methods isInt16Array\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Int32Array 类型，返回 true，否则返回 false\n */\nconst isInt16Array = (val) => {\n  return _type(val) === TYPES.INT16_ARRAY\n}\n\nexport default isInt16Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Uint16Array 的数组\n * ========================================================================\n * methods isUint16Array\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Uint16Array 类型，返回 true，否则返回 false\n */\nconst isUint16Array = (val) => {\n  return _type(val) === TYPES.UNIT16_ARRAY\n}\n\nexport default isUint16Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Int32Array 的数组\n * ========================================================================\n * methods isInt32Array\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Int32Array 类型，返回 true，否则返回 false\n */\nconst isInt32Array = (val) => {\n  return _type(val) === TYPES.INT32_ARRAY\n}\n\nexport default isInt32Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Uint32Array 的数组\n * ========================================================================\n * methods isUint32Array\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Uint32Array 类型，返回 true，否则返回 false\n */\nconst isUint32Array = (val) => {\n  return _type(val) === TYPES.UNIT32_ARRAY\n}\n\nexport default isUint32Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Float32Array 的数组\n * ========================================================================\n * methods isFloat32Array\n * @param {*} val - （必须）待检测的数据\n * @returns {Boolean} 'val' 是 Float64Array 类型，返回 true，否则返回 false\n */\nconst isFloat32Array = (val) => {\n  return _type(val) === TYPES.FLOAT32_ARRAY\n}\n\nexport default isFloat32Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Float64Array 的数组\n * ========================================================================\n * methods isFloat64Array\n * @param {*} val - （必须）待检测的数据\n * @returns {Boolean} 'val' 是 Float64Array 类型，返回 true，否则返回 false\n */\nconst isFloat64Array = (val) => {\n  return _type(val) === TYPES.FLOAT64_ARRAY\n}\n\nexport default isFloat64Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 BigInt64Array 类型。\n * ========================================================================\n * @method isBigInt64Array\n * @since 0.6.0\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 BigInt64Array 类型，返回 true，否则返回 false\n */\nconst isBigInt64Array = (val) => {\n  return _type(val) === TYPES.BIG_INT64_ARRAY\n}\n\nexport default isBigInt64Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 BigUint64Array 类型。\n * ========================================================================\n * @method isBigUint64Array\n * @since 0.6.0\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 BigUint64Array 类型，返回 true，否则返回 false\n */\nconst isBigUint64Array = (val) => {\n  return _type(val) === TYPES.BIG_UINT64_ARRAY\n}\n\nexport default isBigUint64Array\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 BigInt 类型。\n * ========================================================================\n * @method isBigInt\n * @since 0.6.0\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 BigInt 类型，返回 true，否则返回 false\n */\nconst isBigInt = (val) => {\n  return _type(val) === TYPES.BIG_INT\n}\n\nexport default isBigInt\n","import isString from './isString'\n\n/**\n * 检测测试数据是否为一个基于 base64 编码的字符串。\n * ========================================================================\n * @method isBase64\n * @param {String} val - 要检测的数据\n * @return {Boolean} 'val' 是 base64 编码的字符串，返回 true，否则返回 false\n */\nconst isBase64 = (val) => {\n  const REGEXP_BASE64 =\n    /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}={2})$/gm\n  return isString(val) && (!val.length || REGEXP_BASE64.test(val))\n}\n\nexport default isBase64\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Boolean 类型\n * ========================================================================\n * @method isBoolean\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Boolean 类型，则返回 true，否则返回 false\n */\nconst isBoolean = (val) => {\n  return _type(val) === TYPES.BOOLEAN\n}\n\nexport default isBoolean\n","import isFunction from './isFunction'\nimport isNativeFunction from './isNativeFunction'\n\n/**\n * 检测测试函数是否为构造函数\n * ========================================================================\n * @method isConstructor\n * @category Lang\n * @param {Function|Object} fn - 要测试的（构造）函数\n * @returns {Boolean} - fn 是构造函数，返回 true，否则返回 false;\n */\nconst isConstructor = (fn) => {\n  const proto = fn.prototype\n  let instance\n\n  if (!isFunction(fn) || !proto) {\n    return false\n  }\n\n  // 判断 fn 是否为 Promise 构造函数\n  if (isNativeFunction(fn) && proto?.then) {\n    instance = new fn((resolve, reject) => {})\n  } else {\n    instance = new fn()\n  }\n\n  // 判断 constructor\n  return (\n    (instance.constructor === fn && instance instanceof fn) ||\n    (instance.constructor === Object && instance instanceof Object)\n  )\n}\n\nexport default isConstructor\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 DataView 类型\n * ========================================================================\n * @method isDataView\n * @param {*} val - 要检测的数据\n * @return {Boolean} 'val' 是 DataView 类型，返回 true，否则返回 false\n */\nconst isDataView = (val) => {\n  return _type(val) === TYPES.DATA_VIEW\n}\n\nexport default isDataView\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 Date 类型\n * ========================================================================\n * @method isDate\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 Date 类型，返回 true，否则返回 false\n */\nconst isDate = (val) => {\n  return (\n    _type(val) === TYPES.DATE &&\n    val.toString() !== 'Invalid Date' &&\n    !isNaN(val)\n  )\n}\n\nexport default isDate\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 HTML 元素节点。\n * ========================================================================\n * @method isElement\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 HTML 元素节点，返回 true，否则返回 false\n */\nconst isElement = (val) => {\n  return _type(val) === TYPES.ELEMENT\n}\n\nexport default isElement\n","import isArray from './isArray'\n\n/**\n * 检测测试数据是否为空字数组\n * ========================================================================\n * @method isEmptyArray\n * @since 0.5.0\n * @param {Array} val - （必须）待检测的数据\n * @returns {Boolean} 'val' 是空数组，返回 true，否则返回 false\n */\nconst isEmptyArray = (val) => {\n  return isArray(val) && val.length === 0\n}\n\nexport default isEmptyArray\n","import isPlainObject from './isPlainObject'\nimport hasOwn from './hasOwn'\n\n/**\n * 检测测试数据是否为空（单体）对象\n * ========================================================================\n * @method isEmptyObject\n * @param {Object} obj - 要检测的数据\n * @returns {Boolean} 'val' 是空对象，返回 true，否则返回 false\n */\nconst isEmptyObject = (obj) => {\n  let prop\n\n  if (!isPlainObject(obj)) {\n    return false\n  }\n\n  for (prop in obj) {\n    /* istanbul ignore else */\n    if (hasOwn(obj, prop)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport default isEmptyObject\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Error 类型\n * ========================================================================\n * @method isError\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Error 类型，返回 true，否则返回 false\n */\nconst isError = (val) => {\n  return _type(val) === TYPES.ERROR\n}\n\nexport default isError\n","import isInteger from './isInteger'\n\n/**\n * 检测测试数据的数据类型是否为偶数\n * ========================================================================\n * @method isEven\n * @param {Number} val - 要检测的数据\n * @returns {Boolean} 'val' 是偶数，返回 true，否则返回 false\n */\nconst isEven = (val) => {\n  return isInteger(val) && val % 2 === 0\n}\n\nexport default isEven\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据的数据类型是否为 DocumentFragment 文档碎片。\n * ========================================================================\n * @method isFragment\n * @since 0.6.0\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 DocumentFragment 文档碎片，返回 true，否则返回 false\n */\nconst isFragment = (val) => {\n  return _type(val) === TYPES.FRAGMENT\n}\n\nexport default isFragment\n","import isPlainObject from './isPlainObject'\n\n/**\n * 检测测试数据是否为空（单体）对象\n * ========================================================================\n * @method isHash\n * @alias isPlainObject\n * @since 0.4.0\n * @category Lang\n * @param {Object} obj - 要检测的数据\n * @returns {Boolean} 'val' 是普通对象，返回 true，否则返回 false\n */\nconst isHash = (obj) => {\n  return isPlainObject(obj)\n}\n\nexport default isHash\n","import isString from './isString'\n\n/**\n * 检测测试数据是否为 16 进制编码的字符串\n * ========================================================================\n * @method isHex\n * @param {String} val - 要检测的数据\n * @returns {Boolean} 'val' 是 16 进制编码的字符串，返回 true，否则返回 false\n */\nconst isHex = (val) => {\n  const REGEXP_HEX = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\n  return isString(val) && REGEXP_HEX.test(val)\n}\n\nexport default isHex\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测数据的是否为 HTMLNodeList 对象\n * ========================================================================\n * @method isHTMLCollection\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 HTMLNodeList 对象，返回 true，否则返回 false\n */\nconst isHTMLCollection = (val) => {\n  return _type(val) === TYPES.COLLECTION\n}\n\nexport default isHTMLCollection\n","import isString from './isString'\n\n/**\n * 验证是否为（v4 or v6） IP 地址\n * ========================================================================\n * @method isIPAddress\n * @category Lang\n * @param {String} str - 待检测的数据（字符串）\n * @returns {Boolean} 'val' 是 IP 地址，返回 true，否则返回 false\n */\nconst isIPAddress = (str) => {\n  const ipV6 =\n    /(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]+|::(ffff(:0{1,4})?:)?((25[0-5]|(2[0-4]|1?\\d)?\\d)\\.){3}(25[0-5]|(2[0-4]|1?\\d)?\\d)|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1?\\d)?\\d)\\.){3}(25[0-5]|(2[0-4]|1?\\d)?\\d))/\n  const ipV4 =\n    /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/\n  return isString(str) && (ipV4.test(str) || ipV6.test(str))\n}\n\nexport default isIPAddress\n","import isNumber from './isNumber'\n/**\n * 检测测试数据是否为有效 length 值\n * =============================================================\n * @method isLength\n * @param {Number} val - 要检测的数据\n * @returns {Boolean} 'val' 是有效 length 值，返回 true，否则返回 false\n */\nconst isLength = (val) => {\n  const MAX_SAFE_INTEGER = 9007199254740991\n\n  return isNumber(val) && val > -1 && val % 1 === 0 && val <= MAX_SAFE_INTEGER\n}\n\nexport default isLength\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Map 类型\n * ========================================================================\n * @method isMap\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Map 类型，返回 true，否则返回 false\n */\nconst isMap = (val) => {\n  return _type(val) === TYPES.MAP\n}\n\nexport default isMap\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 null\n * ========================================================================\n * @method isNull\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 为 null，返回 true，否则返回 false\n */\nconst isNull = (val) => {\n  return _type(val) === TYPES.NULL\n}\n\nexport default isNull\n","import isNumber from './isNumber'\nimport isString from './isString'\n\n/**\n * 检测测试数据是否是一个数字（只能是 number 类型或者 '123123' 这样的数字字符串）\n * ========================================================================\n * @method isNumeric\n * @category Lang\n * @param {Number|String} val - 要检测的数据\n * @returns {Boolean} 'val' 是一个数字，返回 true，否则返回false\n */\nconst isNumeric = (val) => {\n  return (isNumber(val) || isString(val)) && !isNaN(val - parseFloat(val))\n}\n\nexport default isNumeric\n","import isInteger from './isInteger'\n\n/**\n * 检测测试数据的数据类型是否为奇数\n * ========================================================================\n * @method isOdd\n * @param {Number} val - 要检测的数据\n * @returns {Boolean} 'val' 是奇数，返回 true，否则返回 false\n */\nconst isOdd = (val) => {\n  return isInteger(val) && val % 2 !== 0\n}\n\nexport default isOdd\n","import isString from './isString'\n\n/**\n * 检测是否为电话号码\n * ========================================================================\n * @method isPhoneNumber\n * @category Lang\n * @param {String} str - 要检测的数据\n * @returns {Boolean} 'val' 是 电话号码 格式，返回 true，否则返回 false\n *\n * @example\n * // 移动电话号码\n * isPhoneNumber(13901030304) // -> false\n * isPhoneNumber('1390103030a') // => false\n *\n * isPhoneNumber('+86 13901030304')\n * isPhoneNumber('13901030304')\n * isPhoneNumber('139-010-30304')\n * isPhoneNumber('139.010.30304')\n *\n * // 固定电话号码\n * isPhoneNumber('+86 84923296') // -> true\n * isPhoneNumber('027 84923296') // -> true\n * isPhoneNumber('(027) 84923296') // -> true\n * isPhoneNumber('(027)84923296') // -> true\n * isPhoneNumber('027-84923296') // -> true\n * isPhoneNumber('027.84923296') // -> true\n * isPhoneNumber('027 849-23296') // -> true\n * isPhoneNumber('027-849-23296') // -> true\n */\nconst isPhoneNumber = (str) => {\n  const pattern =\n    /^\\+?\\(?(\\d{2,3})?\\)?[-\\s.]?((\\d{3}[-\\s.]?\\d{4,6})|(\\d{11}))$/im\n  return isString(str) && pattern.test(str)\n}\n\nexport default isPhoneNumber\n","import _type from './_type'\nimport isObject from './isObject'\nimport TYPES from './enum/types'\n\n/**\n * 检测数据是否为 Promise 对象\n * ========================================================================\n * @method isPromise\n * @since 1.3.0\n * @category Lang\n * @param {Object} val - 测试数据\n * @returns {Boolean} 'val' 是 Promise 对象，返回 true，否则返回 false\n */\nconst isPromise = (val) => {\n  return isObject(val) && _type(val) === TYPES.PROMISE\n}\n\nexport default isPromise\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为正则表达式\n * ========================================================================\n * @method isRegExp\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是正则表达式，返回 true，否则返回 false\n */\nconst isRegExp = (val) => {\n  return _type(val) === TYPES.REGEXP\n}\n\nexport default isRegExp\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Set 类型\n * ========================================================================\n * @method isSet\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Set 类型，返回 true，否则返回 false\n */\nconst isSet = (val) => {\n  return _type(val) === TYPES.SET\n}\n\nexport default isSet\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 Symbol 类型\n * ========================================================================\n * @method isSymbol\n * @category Lang\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 Symbol 类型，返回 true，否则返回 false\n */\nconst isSymbol = (val) => {\n  return _type(val) === TYPES.SYMBOL\n}\n\nexport default isSymbol\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为文本节点\n * ========================================================================\n * @method isTextNode\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是文本节点，返回 true，否则返回 false\n */\nconst isTextNode = (val) => {\n  const type = _type(val)\n  return type === TYPES.TEXT\n}\n\nexport default isTextNode\n","import _type from './_type'\n/**\n * 检测测试数据是否为 TypedArray 类型\n * ========================================================================\n * @method isTypedArray\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 type arrays 类型，返回 true，否则返回 false\n */\nconst isTypedArray = (val) => {\n  const type = _type(val)\n  const isTyped =\n    /^(?:Float(?:32|64)|(Int|Uint)(?:8|16|32)|Uint8Clamped|Big(Int|Uint)64)Array$/i\n  return isTyped.test(type)\n}\n\nexport default isTypedArray\n","import isString from './isString'\n\n/**\n * 判断字符串是否为有效的 URL 地址\n * ========================================================================\n * @method isURL\n * @category Lang\n * @param {String} str - 要检测的字符串\n * @returns {Boolean} 'val' 是有效的 URL 字符串格式，返回 true，否则返回 false\n */\nconst isURL = (str) => {\n  const protocol = '(https?:)?'\n  const user = '([^\\\\/\\\\?\\\\#\\\\:]+)'\n  const password = '(.+)'\n  const auth = '(' + user + ':' + password + '@)?'\n  const domain = '(([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*(\\\\.)?)+[a-z]{2,})'\n  const ip = '((\\\\d{1,3}\\\\.){3}\\\\d{1,3})'\n  const port = '(\\\\:\\\\d+)?'\n  const path = '(\\\\/[-a-z\\\\d%_.~+]*)*'\n  const search = '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'\n  const hash = '(\\\\#[-a-z\\\\d_]*)?'\n  const url =\n    '^' +\n    protocol +\n    '\\\\/\\\\/' +\n    auth +\n    '(' +\n    domain +\n    '|' +\n    ip +\n    ')' +\n    port +\n    path +\n    search +\n    hash +\n    '$'\n  const pattern = new RegExp(url, 'i')\n\n  return isString(str) && !!pattern.test(str)\n}\n\nexport default isURL\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为有效的数据\n * =============================================================\n * @method isValue\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是有效的数据，返回 true，否则返回 false\n */\nconst isValue = (val) => {\n  const type = _type(val)\n\n  switch (type) {\n    case TYPES.NUMBER:\n      return isFinite(val)\n    case TYPES.NULL:\n    case TYPES.UNDEFINED:\n      return false\n    default:\n      return !!type\n  }\n}\n\nexport default isValue\n","import hasOwn from './hasOwn'\nimport isObject from './isObject'\n\n/**\n * 判断是否未 VNode 对象\n * =============================================================\n * @method isVNode\n * @param {Object} node - 要检测的数据\n * @returns {Boolean} 'val' 是 VNode 类型，返回 true，否则返回 false\n */\nconst isVNode = (node) => {\n  return node !== null && isObject(node) && hasOwn(node, 'componentOptions')\n}\n\nexport default isVNode\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 WeakMap 类型\n * ========================================================================\n * @method isWeakMap\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 WeakMap 类型，返回 true，否则返回 false\n */\nconst isWeakMap = (val) => {\n  return _type(val) === TYPES.WEAK_MAP\n}\n\nexport default isWeakMap\n","import _type from './_type'\nimport TYPES from './enum/types'\n\n/**\n * 检测测试数据是否为 WeakSet 类型\n * ========================================================================\n * @method isWeakSet\n * @param {*} val - 要检测的数据\n * @returns {Boolean} 'val' 是 WeakSet 类型，返回 true，否则返回 false\n */\nconst isWeakSet = (val) => {\n  return _type(val) === TYPES.WEAK_SET\n}\n\nexport default isWeakSet\n"],"names":["TYPES","OBJECTS","_type","val","type","Object","prototype","toString","apply","_typeof","name","tagName","nodeType","isNumber","isInteger","isNaN","Number","isFloat","isFinite","isInfinite","Infinity","isString","obj","isBlank","test","isChinese","str","includePunctuation","toRegExp","range","pattern","map","rangeStart","rangeEnd","hexStart","hexEnd","join","RegExp","chineseIdeographs","concat","isEmail","isEmpty","isGuid","guid","replace","TAGS","isJSON","isFunction","isPrototype","OP","Ctor","constructor","proto","_isTime","_isDate","Date","parse","isXML","documentElement","ownerDocument","nodeName","_getExactTypeOfString","html","basic","full","trim","slice","tag","isHTML","isTime","isArray","Array","isArrayLike","isObject","isObjectLike","isNativeFunction","fn","isUndefined","hasOwn","prop","hasOwnProperty","call","isPlainObject","is","_getExactTypeOfNumber","_getExactTypeOfObject","isArrayLikeObject","isArguments","isArrayBuffer","isInt8Array","isUint8Array","isUint8ClampedArray","isInt16Array","isUint16Array","isInt32Array","isUint32Array","isFloat32Array","isFloat64Array","isBigInt64Array","isBigUint64Array","isBigInt","isBase64","length","isBoolean","isConstructor","instance","then","resolve","reject","isDataView","isDate","isElement","isEmptyArray","isEmptyObject","isError","isEven","isFragment","isHash","isHex","isHTMLCollection","isIPAddress","isLength","isMap","isNull","isNumeric","parseFloat","isOdd","isPhoneNumber","isPromise","isRegExp","isSet","isSymbol","isTextNode","isTypedArray","isURL","isValue","isVNode","node","isWeakMap","isWeakSet"],"mappings":"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AAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAET,CAAC,MAAQ,OAGT,CAAC,MAAQ,SAcED,GAEEd,KAAKE,EAAG,ECxHnBc,EAAWrC,GAGRkB,EAASlB,IADd,oKAC8BqB,KAAKrB,GCHjCsC,EAAWtC,GACRkB,EAASlB,IAAgB,KAARA,ECApBuC,EAAUhB,IAMd,IAAIiB,EAEJ,QAAKtB,EAASK,KAIdiB,EAAOjB,EAAIkB,QAAQ,UAAW,IAV5B,sFAYwBpB,KAAKmB,IAV7B,kFAU4DnB,KAAKmB,GAAI,ECxBnEE,EAAO,CACX,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,OACA,WACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,UACA,MACA,WACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,SACA,SACA,UACA,SACA,OACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,QACA,KACA,QACA,IACA,KACA,MACA,QACA,OC7GIC,EAAU3C,MACTkB,EAASlB,IAAQoB,EAAQpB,KAASA,KASvCA,GAJAA,GADAA,EAAMA,EAAIyC,QAAQ,yCAA0C,MAClDA,QACR,8DACA,MAEQA,QAAQ,uBAAwB,IAEnC,gBAAgBpB,KAAKrB,ICXxB4C,EAAc5C,GACLD,EAAMC,KACHH,ECJZgD,EAAe7C,IACnB,MAAM8C,EAAK5C,OAAOC,UACZ4C,EAAO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"}